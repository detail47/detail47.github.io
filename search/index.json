[{"content":"åŸºæœ¬åŸç† è¿­ä»£ç¡¬é˜ˆå€¼ç®—æ³•ï¼ˆIterative Hard Thresholding, IHTï¼‰ï¼Œåœ¨æå‡ºæ—¶ç§°M-Sparse Algorithmã€‚$M$ç¨€ç–é—®é¢˜å¯ä»¥è¡¨ç¤ºä¸º $$ \\min_\\mathbf y\\lVert \\mathbf x - \\Phi\\mathbf y \\rVert^2_2\\quad \\text{s.t.}\\quad \\lVert\\mathbf y\\rVert_0\\le M, $$å¯ä»¥å¾—åˆ°å…¶è¿­ä»£ç®—æ³•\n$$ \\mathbf y^{n+1}=H_M(\\mathbf y^n+\\Phi^\\text H(\\mathbf x-\\Phi\\mathbf y^n)), $$å…¶ä¸­ï¼Œ$H_M$ä¸ºéçº¿æ€§ç®—å­ï¼Œå…¶è¿”å›$M$ç»´æœ€å¤§å¹…å€¼\n$$ H_M(y_i)= \\left\\{ \\begin{align} 0\\quad \\lvert y_i\\rvert\\lt\\lambda^{0.5}_M(\\mathbf y)\\\\ y_i\\quad \\lvert y_i\\rvert\\ge\\lambda^{0.5}_M(\\mathbf y) \\end{align} \\right.. $$æ¨å¯¼è¿‡ç¨‹ æ›¿ä»£ç›®æ ‡å‡½æ•°ï¼ˆSurrogate Objective Functionï¼‰ $$ C_M^S(\\mathbf{y,z})=\\lVert \\mathbf{x-\\Phi y} \\rVert_2^2 - \\lVert \\mathbf{\\Phi y-\\Phi z} \\rVert_2^2 + \\lVert \\mathbf{y-z} \\rVert_2^2 \\qquad \\lVert\\mathbf\\Phi\\rVert_2\\lt1, $$å½“$\\mathbf{y=z}$æ—¶ï¼Œè¯¥å‡½æ•°å³ä¸ºåŸç›®æ ‡å‡½æ•°ï¼Œå…¶ä½™æƒ…å†µä¸‹å‡å¤§äºç›®æ ‡å‡½æ•°ã€‚$\\lVert\\mathbf\\Phi\\rVert_2\\lt1$ç”±$0\\lt eig(\\mathbf I-\\mathbf \\Phi^\\text{H} \\mathbf\\Phi)\\lt 1$æ¨å¯¼å‡ºã€‚\næ›¿ä»£ç›®æ ‡å‡½æ•°å˜å½¢ $$ C_M^S(\\mathbf{y,z})=\\sum_i[y_i^2-2y_i(z_i+\\phi_i^\\text{T}\\mathbf x-\\phi_i^\\text{T}\\mathbf{\\Phi z})]+\\lVert\\mathbf x\\rVert_2^2+\\lVert\\mathbf z\\rVert_2^2+\\lVert\\mathbf{\\Phi z}\\rVert_2^2, $$ç”±äºä¼˜åŒ–ç›®æ ‡ä¸º$\\mathbf y$ï¼Œè€Œåé¢ä¸‰é¡¹ä¸å…¶æ— å…³ã€‚å› æ­¤ï¼Œå¯¹å…¶ä¼˜åŒ–æ—¶å¿½ç•¥è¿™ä¸‰é¡¹ä¸å½±å“ç»“æœã€‚\n$$ C_M^S(\\mathbf{y,z})\\propto\\sum_i[y_i^2-2y_i(z_i+\\phi_i^\\text{T}\\mathbf x-\\phi_i^\\text{T}\\mathbf{\\Phi z})]. $$æå€¼ç‚¹è·å– $$ y_i^*=z_i+\\phi_i^\\text H\\mathbf x-\\phi_i^\\text H\\mathbf{\\Phi z}, $$æå€¼ç‚¹é€šè¿‡ç®€å•çš„é…æ–¹æ³•å³å¯è·å¾—ã€‚è¿™æ—¶ï¼Œå–å¾—æœ€å°å€¼$\\sum_i{-(y_i^*)^2}$ã€‚\nè¿­ä»£å…¬å¼è·å– è€ƒè™‘åˆ°$\\lVert\\mathbf y\\rVert_0\\le M$çš„çº¦æŸï¼Œéœ€è¦ä¿ç•™$\\lVert\\mathbf y^*\\rVert$çš„æœ€å¤§$M$é¡¹ï¼Œå³ä½¿ç”¨ç¡¬é˜ˆå€¼å‡½æ•°ã€‚\nä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 function [s, err_mse, iter_time]=hard_l0_Mterm(x,A,m,M,varargin) % hard_l0_Mterm: Hard thresholding algorithm that keeps exactly M elements % in each iteration. % % This algorithm has certain performance guarantees as described in [1], % [2] and [3]. % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Usage % % [s, err_mse, iter_time]=hard_l0_Mterm(x,P,m,M,\u0026#39;option_name\u0026#39;,\u0026#39;option_value\u0026#39;) % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % % Input % % Mandatory: % x Observation vector to be decomposed % P Either: % 1) An nxm matrix (n must be dimension of x) % 2) A function handle (type \u0026#34;help function_format\u0026#34; % for more information) % Also requires specification of P_trans option. % 3) An object handle (type \u0026#34;help object_format\u0026#34; for % more information) % m length of s % M non-zero elements to keep in each iteration % % Possible additional options: % (specify as many as you want using \u0026#39;option_name\u0026#39;,\u0026#39;option_value\u0026#39; pairs) % See below for explanation of options: %__________________________________________________________________________ % option_name | available option_values | default %-------------------------------------------------------------------------- % stopTol | number (see below) | 1e-16 % P_trans | function_handle (see below) | % maxIter | positive integer (see below) | n^2 % verbose | true, false | false % start_val | vector of length m | zeros % step_size | number | 0 (auto) % % stopping criteria used : (OldRMS-NewRMS)/RMS(x) \u0026lt; stopTol % % stopTol: Value for stopping criterion. % % P_trans: If P is a function handle, then P_trans has to be specified and % must be a function handle. % % maxIter: Maximum number of allowed iterations. % % verbose: Logical value to allow algorithm progress to be displayed. % % start_val: Allows algorithms to start from partial solution. % % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % % Outputs % % s Solution vector % err_mse Vector containing mse of approximation error for each % iteration % iter_time Vector containing computation times for each iteration % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % % Description % % Implements the M-sparse algorithm described in [1], [2] and [3]. % This algorithm takes a gradient step and then thresholds to only retain % M non-zero elements. It allows the step-size to be calculated % automatically as described in [3] and is therefore now independent from % a rescaling of P. % % % References % [1] T. Blumensath and M.E. Davies, \u0026#34;Iterative Thresholding for Sparse % Approximations\u0026#34;, submitted, 2007 % [2] T. Blumensath and M. Davies; \u0026#34;Iterative Hard Thresholding for % Compressed Sensing\u0026#34; to appear Applied and Computational Harmonic % Analysis % [3] T. Blumensath and M. Davies; \u0026#34;A modified Iterative Hard % Thresholding algorithm with guaranteed performance and stability\u0026#34; % in preparation (title may change) % See Also % hard_l0_reg % % Copyright (c) 2007 Thomas Blumensath % % The University of Edinburgh % Email: thomas.blumensath@ed.ac.uk % Comments and bug reports welcome % % This file is part of sparsity Version 0.4 % Created: April 2007 % Modified January 2009 % % Part of this toolbox was developed with the support of EPSRC Grant % D000246/1 % % Please read COPYRIGHT.m for terms and conditions. %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Default values and initialisation %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% [n1 n2]=size(x); if n2 == 1 n=n1; elseif n1 == 1 x=x\u0026#39;; n=n2; else error(\u0026#39;x must be a vector.\u0026#39;); end sigsize = x\u0026#39;*x/n; oldERR = sigsize; err_mse = []; iter_time = []; STOPTOL = 1e-16; MAXITER = n^2; verbose = false; initial_given=0; s_initial = zeros(m,1); MU = 0; if verbose display(\u0026#39;Initialising...\u0026#39;) end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Output variables %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% switch nargout case 3 comp_err=true; comp_time=true; case 2 comp_err=true; comp_time=false; case 1 comp_err=false; comp_time=false; case 0 error(\u0026#39;Please assign output variable.\u0026#39;) otherwise error(\u0026#39;Too many output arguments specified\u0026#39;) end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Look through options %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Put option into nice format Options={}; OS=nargin-4; c=1; for i=1:OS if isa(varargin{i},\u0026#39;cell\u0026#39;) CellSize=length(varargin{i}); ThisCell=varargin{i}; for j=1:CellSize Options{c}=ThisCell{j}; c=c+1; end else Options{c}=varargin{i}; c=c+1; end end OS=length(Options); if rem(OS,2) error(\u0026#39;Something is wrong with argument name and argument value pairs.\u0026#39;) end for i=1:2:OS switch Options{i} case {\u0026#39;stopTol\u0026#39;} if isa(Options{i+1},\u0026#39;numeric\u0026#39;) ; STOPTOL = Options{i+1}; else error(\u0026#39;stopTol must be number. Exiting.\u0026#39;); end case {\u0026#39;P_trans\u0026#39;} if isa(Options{i+1},\u0026#39;function_handle\u0026#39;); Pt = Options{i+1}; else error(\u0026#39;P_trans must be function _handle. Exiting.\u0026#39;); end case {\u0026#39;maxIter\u0026#39;} if isa(Options{i+1},\u0026#39;numeric\u0026#39;); MAXITER = Options{i+1}; else error(\u0026#39;maxIter must be a number. Exiting.\u0026#39;); end case {\u0026#39;verbose\u0026#39;} if isa(Options{i+1},\u0026#39;logical\u0026#39;); verbose = Options{i+1}; else error(\u0026#39;verbose must be a logical. Exiting.\u0026#39;); end case {\u0026#39;start_val\u0026#39;} if isa(Options{i+1},\u0026#39;numeric\u0026#39;) \u0026amp;\u0026amp; length(Options{i+1}) == m ; s_initial = Options{i+1}; initial_given=1; else error(\u0026#39;start_val must be a vector of length m. Exiting.\u0026#39;); end case {\u0026#39;step_size\u0026#39;} if isa(Options{i+1},\u0026#39;numeric\u0026#39;) \u0026amp;\u0026amp; (Options{i+1}) \u0026gt; 0 ; MU = Options{i+1}; else error(\u0026#39;Stepsize must be between a positive number. Exiting.\u0026#39;); end otherwise error(\u0026#39;Unrecognised option. Exiting.\u0026#39;) end end if nargout \u0026gt;=2 err_mse = zeros(MAXITER,1); end if nargout ==3 iter_time = zeros(MAXITER,1); end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Make P and Pt functions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% if isa(A,\u0026#39;float\u0026#39;) P =@(z) A*z; Pt =@(z) A\u0026#39;*z; elseif isobject(A) P =@(z) A*z; Pt =@(z) A\u0026#39;*z; elseif isa(A,\u0026#39;function_handle\u0026#39;) try if isa(Pt,\u0026#39;function_handle\u0026#39;); P=A; else error(\u0026#39;If P is a function handle, Pt also needs to be a function handle. Exiting.\u0026#39;); end catch error(\u0026#39;If P is a function handle, Pt needs to be specified. Exiting.\u0026#39;); end else error(\u0026#39;P is of unsupported type. Use matrix, function_handle or object. Exiting.\u0026#39;); end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Do we start from zero or not? %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% if initial_given ==1; if length(find(s_initial)) \u0026gt; M display(\u0026#39;Initial vector has more than M non-zero elements. Keeping only M largest.\u0026#39;) end s = s_initial; [ssort sortind] = sort(abs(s),\u0026#39;descend\u0026#39;); s(sortind(M+1:end)) = 0; Ps = P(s); Residual = x-Ps; oldERR = Residual\u0026#39;*Residual/n; else s_initial = zeros(m,1); Residual = x; s = s_initial; Ps = zeros(n,1); oldERR = sigsize; end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Random Check to see if dictionary norm is below 1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% x_test=randn(m,1); x_test=x_test/norm(x_test); nP=norm(P(x_test)); if abs(MU*nP)\u0026gt;1; display(\u0026#39;WARNING! Algorithm likely to become unstable.\u0026#39;) display(\u0026#39;Use smaller step-size or || P ||_2 \u0026lt; 1.\u0026#39;) end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Main algorithm %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% if verbose display(\u0026#39;Main iterations...\u0026#39;) end tic t=0; done = 0; iter=1; while ~done if MU == 0 %Calculate optimal step size and do line search olds = s; oldPs = Ps; IND = s~=0; d = Pt(Residual); % If the current vector is zero, we take the largest elements in d if sum(IND)==0 [dsort sortdind] = sort(abs(d),\u0026#39;descend\u0026#39;); IND(sortdind(1:M)) = 1; end id = (IND.*d); Pd = P(id); mu = id\u0026#39;*id/(Pd\u0026#39;*Pd); s = olds + mu * d; [ssort sortind] = sort(abs(s),\u0026#39;descend\u0026#39;); s(sortind(M+1:end)) = 0; Ps = P(s); % Calculate step-size requirement omega = (norm(s-olds)/norm(Ps-oldPs))^2; % As long as the support changes and mu \u0026gt; omega, we decrease mu while mu \u0026gt; (0.99)*omega \u0026amp;\u0026amp; sum(xor(IND,s~=0))~=0 \u0026amp;\u0026amp; sum(IND)~=0 % display([\u0026#39;decreasing mu\u0026#39;]) % We use a simple line search, halving mu in each step mu = mu/2; s = olds + mu * d; [ssort sortind] = sort(abs(s),\u0026#39;descend\u0026#39;); s(sortind(M+1:end)) = 0; Ps = P(s); % Calculate step-size requirement omega = (norm(s-olds)/norm(Ps-oldPs))^2; end else % Use fixed step size s = s + MU * Pt(Residual); [ssort sortind] = sort(abs(s),\u0026#39;descend\u0026#39;); s(sortind(M+1:end)) = 0; Ps = P(s); end Residual = x-Ps; ERR=Residual\u0026#39;*Residual/n; if comp_err err_mse(iter)=ERR; end if comp_time iter_time(iter)=toc; end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Are we done yet? %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% if comp_err \u0026amp;\u0026amp; iter \u0026gt;=2 if ((err_mse(iter-1)-err_mse(iter))/sigsize\u0026lt;STOPTOL); if verbose display([\u0026#39;Stopping. Approximation error changed less than \u0026#39; num2str(STOPTOL)]) end done = 1; elseif verbose \u0026amp;\u0026amp; toc-t\u0026gt;10 display(sprintf(\u0026#39;Iteration %i. --- %i mse change\u0026#39;,iter ,(err_mse(iter-1)-err_mse(iter))/sigsize)) t=toc; end else if ((oldERR - ERR)/sigsize \u0026lt; STOPTOL) \u0026amp;\u0026amp; iter \u0026gt;=2; if verbose display([\u0026#39;Stopping. Approximation error changed less than \u0026#39; num2str(STOPTOL)]) end done = 1; elseif verbose \u0026amp;\u0026amp; toc-t\u0026gt;10 display(sprintf(\u0026#39;Iteration %i. --- %i mse change\u0026#39;,iter ,(oldERR - ERR)/sigsize)) t=toc; end end % Also stop if residual gets too small or maxIter reached if comp_err if err_mse(iter)\u0026lt;1e-16 display(\u0026#39;Stopping. Exact signal representation found!\u0026#39;) done=1; end elseif iter\u0026gt;1 if ERR\u0026lt;1e-16 display(\u0026#39;Stopping. Exact signal representation found!\u0026#39;) done=1; end end if iter \u0026gt;= MAXITER display(\u0026#39;Stopping. Maximum number of iterations reached!\u0026#39;) done = 1; end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % If not done, take another round %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% if ~done iter=iter+1; oldERR=ERR; end end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Only return as many elements as iterations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% if nargout \u0026gt;=2 err_mse = err_mse(1:iter); end if nargout ==3 iter_time = iter_time(1:iter); end if verbose display(\u0026#39;Done\u0026#39;) end ","date":"2026-02-10T00:00:00Z","permalink":"https://detail47.github.io/p/iht/","title":"IHT"},{"content":"åŸºæœ¬åŸç† Majorization-Minimizationä¼˜åŒ–æ¡†æ¶åœ¨å„ç±»ç®—æ³•ä¸­å¾ˆå¸¸è§ã€‚åœ¨ç›®æ ‡å‡½æ•°$J(x)$éš¾ä¼˜åŒ–æ—¶ï¼Œå¯ä»¥å¯»æ‰¾ä¸€ä¸ªå®¹æ˜“ä¼˜åŒ–çš„ç›®æ ‡å‡½æ•°$G(x)$ï¼Œå½“$G(x)$æ»¡è¶³ä¸€å®šæ¡ä»¶æ—¶ï¼Œ$G(x)$çš„æœ€ä¼˜è§£èƒ½æ— é™é€¼è¿‘$J(x)$çš„æœ€ä¼˜è§£ã€‚ $G(x)$åº”è¯¥æ»¡è¶³çš„æ¡ä»¶ å®¹æ˜“ä¼˜åŒ– $G_k(x)\\ge J(x)$ $G_k(x_k)=J(x_k)$ ä¼˜åŒ–è¿‡ç¨‹ è€ƒè™‘ä¸€ä¸ªä¼˜åŒ–é—®é¢˜ï¼Œ$\\mathscr X$ä¸ºé—­å‡¸é›†ã€$J(\\mathbf x)$è¿ç»­\n$$ \\min_\\mathbf x J(\\mathbf x)\\quad \\text{s.t.} \\quad x \\in \\mathscr X. $$\n1 2 3 4 5 6 7 8 9 10 \\begin{algorithm} \\caption{Majorization Minimization} \\begin{algorithmic} \\STATE å¯»æ‰¾ä¸€ä¸ªå¯è¡Œç‚¹$x^0 \\in \\mathscr Xï¼Œk \\gets 0$ \\REPEAT \\STATE $\\mathbf x^{k+1}=\\arg\\min_{x\\in \\mathscr X} G_k(\\mathbf{x})$ \\STATE $k\\gets k+1$ \\UNTIL{æ»¡è¶³ä¸€äº›æ¡ä»¶} \\end{algorithmic} \\end{algorithm} ","date":"2026-01-23T00:00:00Z","image":"https://detail47.github.io/p/mm-%E4%BC%98%E5%8C%96%E6%A1%86%E6%9E%B6/b5b3d6bcffab9a324c9342ea9be2ec59_hu_e48199f4f58a3fae.png","permalink":"https://detail47.github.io/p/mm-%E4%BC%98%E5%8C%96%E6%A1%86%E6%9E%B6/","title":"MM ä¼˜åŒ–æ¡†æ¶"},{"content":"æµç¨‹å›¾ é…å‡† å¼ºåº¦å›¾åƒé‡‘å­—å¡” ä½¿ç”¨ä¸»è¾…å›¾åƒçš„å¹…å€¼æ„å»ºå½±åƒé‡‘å­—å¡”ï¼Œè‡ªé¡¶å‘ä¸‹é€å±‚å¯¹å›¾åƒè¿›è¡ŒåŒ¹é…ã€‚1ä½¿å¾—æ¯è½®åŒ¹é…çš„æœç´¢èŒƒå›´éƒ½ç›¸å¯¹è¾ƒå°ï¼Œå¿«é€Ÿæ¥è¿‘å¯¹åº”ä½ç½®ã€‚ä»£ç ä¸­é‡‡ç”¨4å±‚é‡‘å­—å¡”ï¼Œä¸Šä¸€å±‚å›¾åƒä¸ºä¸‹ä¸€å±‚å›¾åƒåœ¨è·ç¦»å‘å’Œæ–¹ä½å‘åˆ†åˆ«è¿›è¡Œ2å€ä¸‹é‡‡æ ·å¾—åˆ°ã€‚åŒ¹é…çª—å£ä¸º$21\\times 21$ã€æ¯å±‚æœ€å¤§åç§»ä¸º$15\\times 15$ã€æ§åˆ¶ç‚¹æ•°é‡ä¸º64ã€‚å›¾åƒåç§»é‡ä¸ºæ§åˆ¶ç‚¹åç§»é‡çš„å‡å€¼ã€‚æ§åˆ¶ç‚¹åŒ¹é…é‡‡ç”¨å½’ä¸€åŒ–ç›¸å…³åŒ¹é…ï¼Œä½¿ç”¨ç›¸å…³æ€§æœ€é«˜çš„åç§»é‡ä¸ºè¯¥æ§åˆ¶ç‚¹çš„åç§»é‡ã€‚2\n$$ R\\left( x,y \\right) =\\frac{\\sum_{x^\\prime ,y^\\prime }{M\\left( x^\\prime ,y^\\prime \\right) \\cdot S\\left( x+x^\\prime ,y+y^\\prime \\right)}}{\\sqrt{\\sum_{x^\\prime ,y^\\prime }{M\\left( x^\\prime ,y^\\prime \\right) ^2}\\cdot \\sum_{x^\\prime ,y^\\prime}{S\\left( x+x^\\prime ,y+y^\\prime \\right) ^2}}} $$\næœ€å¤§é¢‘è°±æ³•ç²¾åŒ¹é… ä½¿ç”¨æœ€å¤§é¢‘è°±æ³•å¯¹ä¸»è¾…å›¾åƒè¿›è¡ŒåŒ¹é…ï¼Œä½¿å¾—ä¸»è¾…å›¾åƒå¯¹é½åˆ°äºšåƒå…ƒçº§åˆ«ä»¥æ»¡è¶³åç»­å¤„ç†éœ€æ±‚ã€‚ä»£ç ä¸­é‡‡ç”¨çš„åŒ¹é…çª—å£ä¸º$15\\times 15$ã€æœ€å¤§åç§»ä¸º$3\\times 3$ã€æ§åˆ¶ç‚¹æ•°é‡ä¸º64ï¼Œè®¡ç®—å‰åœ¨å›¾åƒè·ç¦»å‘å’Œæ–¹ä½å‘ä¸Šåˆ†åˆ«è¿›è¡Œ5å€ä¸Šé‡‡æ ·ã€‚æ§åˆ¶ç‚¹åç§»é‡ä½¿ç”¨æœ€å¤§é¢‘è°±æ³•å¾—åˆ°çš„ä¿¡å™ªæ¯”æœ€å¤§çš„åç§»é‡ã€‚3\n$$ u_{int}=u_m\\cdot u_{s}^{*}=a_ma_s\\cdot e^{j\\left( \\varphi _m-\\varphi _s \\right)} $$$$ SNR=\\frac{f_{max}}{\\sum{f_{i,j}}-f_{max}} $$å›¾åƒåç§»é‡ä½¿ç”¨æ§åˆ¶ç‚¹å»é™¤å¥‡å¼‚å€¼ç‚¹å’Œä¿¡å™ªæ¯”è¾ƒä½çš„ç‚¹åï¼Œä½¿ç”¨ä¸‰é˜¶å¤šé¡¹å¼æ‹Ÿåˆã€‚3\n$$ \\left\\{ \\begin{array}{l} \\Delta x=a_0+a_1\\cdot x+a_2\\cdot y+a_3\\cdot xy+a_4\\cdot x^2+a_5\\cdot y^2+a_6\\cdot x^2y+a_7\\cdot xy^2+a_8\\cdot x^3+a_9\\cdot y^3\\\\ \\Delta y=b_0+b_1\\cdot x+b_2\\cdot y+b_3\\cdot xy+b_4\\cdot x^2+b_5\\cdot y^2+b_6\\cdot x^2y+b_7\\cdot xy^2+b_8\\cdot x^3+b_9\\cdot y^3\\\\ \\end{array} \\right. $$æ’å€¼ åº”ç”¨åç§»é‡åˆ°è¾…å›¾åƒä¸Šé‡‡ç”¨å¤æ•°åŒçº¿æ€§æ’å€¼\n$$ f\\left( x,y \\right) =f\\left( Q_{11} \\right) w_{11}+f\\left( Q_{21} \\right) w_{21}+f\\left( Q_{12} \\right) w_{12}+f\\left( Q_{22} \\right) w_{22} $$$$ \\left\\{ \\begin{align} w_{11} \u0026= \\frac{(x_2-x)(y_2-y)}{(x_2-x_1)(y_2-y_1)}\\\\ w_{21} \u0026= \\frac{(x-x_1)(y_2-y)}{(x_2-x_1)(y_2-y_1)}\\\\ w_{12} \u0026= \\frac{(x_2-x)(y-y_1)}{(x_2-x_1)(y_2-y_1)}\\\\ w_{22} \u0026= \\frac{(x-x_1)(y-y_1)}{(x_2-x_1)(y_2-y_1)} \\end{align} \\right. $$å¹²æ¶‰ å¹²æ¶‰å›¾ç”±ä¸»è¾…å›¾åƒå…±è½­ç›¸ä¹˜å¾—åˆ°ï¼Œç›¸å¹²å›¾ç”±å¹²æ¶‰å›¾ç”¨$9\\times 9$çª—å£å‡å€¼æ»¤æ³¢å¹¶å½’ä¸€åŒ–å¾—åˆ°ã€‚3\n$$ \\begin{align} u_{int}\u0026=u_m\\cdot u_{s}^{*}=a_ma_s\\cdot e^{j\\left( \\varphi _m-\\varphi _s \\right)}=a_{int}e^{j\\varphi} \\\\ \\varphi \u0026=\\varphi _\\text{flat}+\\varphi _\\text{topo}+\\varphi _\\text{atm}+\\varphi _\\text{noise} \\end{align} $$$$ \\gamma =\\frac{|E\\left[ M\\cdot S^* \\right] |}{\\sqrt{E\\left[\\mid M\\mid ^2 \\right] E\\left[\\mid S\\mid ^2 \\right]}} $$å»å¹³åœ°æ•ˆåº” æ–œè·$R$å’Œå…¥å°„è§’$\\theta$åœ¨SMLæ–‡ä»¶ä¸­å¾—åˆ°ï¼Œä½¿ç”¨çº¿æ€§æ’å€¼å¯¹æ–œè·$R$è¿›è¡Œæ’å€¼ã€‚$\\Delta ğ‘…$ä¸ºå½“å‰åƒå…ƒä¸ç¬¬ä¸€ä¸ªåƒå…ƒæ–œè·ä¹‹å·®ã€‚ 3 $R_0$ä¸ºç¬¬ä¸€ä¸ªåƒå…ƒçš„æ–œè·ï¼Œ$R_{eq}$ä¸ºå¹²æ¶‰ç›¸ä½ä¸º0æ—¶å¯¹åº”çš„æ–œè·ã€‚\n$$ \\varphi _\\text{flat}=-\\frac{4\\pi}{\\lambda}\\cdot \\frac{B_{\\bot}\\Delta \\text{R}}{Rtan\\left( \\theta \\right)}+\\varphi _\\text{const} $$$$ \\varphi_\\text{const}=-\\frac{4\\pi}{\\lambda}\\cdot \\frac{B_{\\bot}(R_{0}-R_{\\text{eq}})}{R_{0}tan\\left( \\theta \\right)} $$å»å¹³åœ°æ•ˆåº”åçš„å¹²æ¶‰å›¾ç›¸ä½:\n$$ \\begin{align} \\varphi _1\u0026 =\\varphi +\\frac{4\\pi}{\\lambda}\\cdot \\frac{B_{\\bot}\\Delta \\text{R}}{Rtan\\left( \\theta \\right)}\\\\ \u0026 =\\varphi _\\text{topo}+\\varphi _\\text{atm}+\\varphi _\\text{const}+\\varphi _\\text{noise}\\\\ \\end{align} $$å»DEMç›¸ä½ ä½¿ç”¨è½¨é“æ•°æ®å°†DEMæ•°æ®é€ç‚¹ä»WGS84åæ ‡ç³»è½¬æ¢åˆ°é›·è¾¾è·ç¦»-æ–¹ä½åæ ‡ç³»ï¼Œä½¿ç”¨çº¿æ€§æ’å€¼å°†å¾—åˆ°çš„æ•°æ®æ’å€¼åˆ°æ•´ä¸ªé›·è¾¾è·ç¦»-æ–¹ä½åæ ‡ç³»ã€‚é€šè¿‡é«˜ç¨‹ç›¸ä½çš„å…¬å¼å¾—åˆ° 3\n$$ \\varphi _\\text{dem}=-\\frac{4\\pi}{\\lambda}\\cdot \\frac{B_{\\bot}\\text{H}_\\text{dem}}{R\\sin \\left( \\theta \\right)} $$å»DEMç›¸ä½åçš„å¹²æ¶‰å›¾ç›¸ä½:\n$$ \\begin{align} \\varphi _2\u0026 =\\varphi _1-\\varphi _\\text{dem}\\\\ \u0026 =\\varphi _\\text{topo}-\\varphi _\\text{dem}+\\varphi _\\text{atm}+\\varphi _\\text{const}+\\varphi _\\text{noise}\\\\ \u0026 =-\\frac{4\\pi}{\\lambda}\\cdot \\frac{B_{\\bot}\\Delta H}{R\\sin \\left( \\theta \\right)}+\\varphi _\\text{atm}+\\varphi _\\text{const}+\\varphi _\\text{noise} \\quad\\quad (\\Delta H = H - H_\\text{dem})\\\\ \\end{align} $$æ»¤æ³¢ ä½¿ç”¨Goldsteinæ»¤æ³¢ï¼Œå°†å¹²æ¶‰å›¾åˆ†æˆç›¸äº’é‡å çš„å°å—ã€‚å¯¹æ¯ä¸ªå°å—åšå‚…é‡Œå¶å˜æ¢ï¼Œå¾—åˆ°å…¶é¢‘è°±$Z(u,v)$ , ç”¨å…¶å¯¹å¹²æ¶‰å›¾è¿›è¡Œå¤„ç†ã€‚$S[\\cdot]$ ä¸ºå¹³æ»‘ç®—å­ï¼Œä½¿ç”¨$3\\times 3$çš„å‡å€¼æ»¤æ³¢ã€‚Goldsteinæ»¤æ³¢çª—å£å¤§å°ä¸º$32\\times 32$ , æ­¥é•¿ä¸º8 ã€‚45\n$$ H(u,v) = S[ \\lvert Z(u,v)\\rvert ]^{1-\\bar \\gamma}\\cdot Z(u,v) $$å¿½ç•¥æ®‹ä½™å™ªå£°ï¼Œæ»¤æ³¢åå¹²æ¶‰å›¾ç›¸ä½:\n$$ \\varphi_3 = =-\\frac{4\\pi}{\\lambda}\\cdot \\frac{B_{\\bot}\\Delta H}{R\\sin \\left( \\theta \\right)}+\\varphi _\\text{atm}+\\varphi _\\text{const}\\\\ $$å¤§æ°”ç›¸ä½æ ¡æ­£ ç»è¿‡å»å¹³åœ°æ•ˆåº”å’Œå»DEMç›¸ä½åï¼Œç›¸ä½è¿˜å‰©ä½™é«˜é¢‘çš„ç›¸å¯¹é«˜ç¨‹ç›¸ä½ä¸ä½é¢‘çš„å¤§æ°”ç›¸ä½å’Œå›ºå®šç›¸ä½ã€‚å¯¹ç›¸ä½ä½¿ç”¨é«˜é€šæ»¤æ³¢å™¨å»é™¤å¤§æ°”ç›¸ä½å’Œå›ºå®šç›¸ä½ã€‚6 å‡è®¾$E[\\Delta H]=0$\n$$ \\varphi _3=k\\Delta H+\\varphi _\\text{atm}+\\varphi _\\text{const} \\quad\\quad ( k=-\\frac{4\\pi B_{\\bot}}{\\lambda Rsin(\\theta)}) $$å»å¤§æ°”ç›¸ä½åçš„å¹²æ¶‰å›¾ç›¸ä½:\n$$ \\varphi _4=HPF( \\varphi _3) =k\\Delta H $$ é³å›½æ—º. InSARè·å–é«˜ç²¾åº¦DEMå…³é”®å¤„ç†æŠ€æœ¯ç ”ç©¶[D]. è§£æ”¾å†›ä¿¡æ¯å·¥ç¨‹å¤§å­¦, 2007.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nOpenCVè®¡ç®—æœºè§†è§‰åº“. æ¨¡æ¿åŒ¹é…[EB/OL], (2025-7-3). https://docs.opencv.ac.cn/4.12.0/de/da9/tutorial_template_matching.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\næ¨çº¢ç£Š, å½­å†›è¿˜, åº·å¿—å¿ . InSARæŠ€æœ¯åŸç†åŠå®è·µ[M]. åŒ—äº¬ï¼šç§‘å­¦å‡ºç‰ˆç¤¾, 2021.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBARAN I, STEWART M P, KAMPES B M, ç­‰. A modification to the goldstein radar interferogram filter[J]. IEEE Transactions on Geoscience and Remote Sensing, 2003, 41(9): 2114-2118.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nNome2s. InSARFilter[CP/OL], (2025-10-21). https://github.com/Nome2s/InSARFilter.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFORNARO G, LOMBARDINI F, SERAFINO F. Three-dimensional multipass SAR focusing: experiments with long-term spaceborne data[J]. IEEE Transactions on Geoscience and Remote Sensing, 2005, 43(4): 702-714.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-11-21T00:00:00Z","image":"https://detail47.github.io/p/%E6%88%90%E5%83%8F%E9%A2%84%E5%A4%84%E7%90%86/intf_hu_c25d57c8e3dafe05.png","permalink":"https://detail47.github.io/p/%E6%88%90%E5%83%8F%E9%A2%84%E5%A4%84%E7%90%86/","title":"æˆåƒé¢„å¤„ç†"},{"content":"åˆ©ç”¨ä¿¡å·çš„ç¨€ç–æ€§ä½œä¸ºå…ˆéªŒçŸ¥è¯†ï¼Œå®Œæˆå¯¹ä¿¡å·çš„å‹ç¼©ã€‚\nåŸºæœ¬å…¬å¼ $x$ ä¸ºä¿¡å· $s$ ä¸ºç¨€ç–ç³»æ•°ï¼Œ$x=\\Psi s$ $y$ ä¸ºè§‚æµ‹å€¼ï¼Œ$y = \\Phi\\Psi s = Rs$ $\\Phi$ ä¸ºè§‚æµ‹çŸ©é˜µ $\\Psi$ ä¸ºç¨€ç–çŸ©é˜µ $L_0$æœ€å°èŒƒæ•°(ç†è®ºè§£) $$ \\min_s \\Vert s\\Vert_0\\quad s.t. \\quad y=Rs $$$L_1$æœ€å°èŒƒæ•° æ±‚è§£$L_0$æœ€å°èŒƒæ•°æ˜¯NP-hardé—®é¢˜ï¼Œä½†å¦‚æœä¿¡å·è¶³å¤Ÿç¨€ç–ï¼ˆ$N \\gg O(Klog(L/K))$ï¼‰ï¼Œå¯ä»¥ä½¿ç”¨$L_1$æœ€å°èŒƒæ•°å¾—åˆ°ç›¸åŒç»“æœã€‚\n$$ \\min_s \\Vert s\\Vert_1\\quad s.t. \\quad y=Rs $$å­˜åœ¨å™ªå£°çš„æƒ…å†µä¸‹ æ²¡æœ‰Kçš„å…ˆéªŒçŸ¥è¯† $$ \\hat s = \\arg\\min_s{\\{\\Vert y-Rs\\Vert_2^2+\\lambda_K\\Vert s\\Vert_1\\}} $$$\\lambda_K$ä¸ºæ‹‰æ ¼æœ—æ—¥ä¹˜å­ï¼Œå–å†³äºé‡‡æ ·ç‚¹æ•°$N$å’Œå™ªå£°æ°´å¹³$\\sigma_\\varepsilon$\næœ‰Kçš„å…ˆéªŒçŸ¥è¯† $$ \\hat s= \\min_s \\Vert s\\Vert_1\\quad s.t. \\quad \\Vert y-Rs\\Vert_2 \\lt \\sigma_\\varepsilon $$éç›¸å…³æ€§ é€šè¿‡æœ€å¤§åŒ–æ¯æ¬¡æµ‹é‡çš„ä¿¡æ¯æ•ˆç‡ï¼Œåˆ†æ•£ä¿¡å·ç‰¹å¾åˆ°æ‰€æœ‰é‡‡æ ·ç‚¹ä¸­ã€‚\n$$\\mu(\\mathrm{\\bf{R}})=\\mu(\\bf{\\Phi},\\bf{\\Psi})=\\sqrt{N}\\operatorname*{max}_{1\\leq k,j\\leq N}\\frac{\\vert\\langle\\varphi_{k},\\psi_{j}\\rangle\\vert}{\\Vert\\varphi_{k}\\Vert_2\\Vert\\psi_{j}\\Vert_2}$$å…¸å‹æµ‹é‡åŸº$\\Phi$ å’Œç¨€ç–åŸº$\\Psi$ç»„åˆ\nå‚…é‡Œå¶çŸ©é˜µ+å•ä½çŸ©é˜µï¼šå½“ä¿¡å·è‡ªèº«å…·æœ‰ç¨€ç–æ€§æ—¶ å™ªå£°åŸº+å°æ³¢åŸº éšæœºçŸ©é˜µ+ä»»æ„å›ºå®šåŸº é™åˆ¶ç­‰è·æ¡ä»¶(RIP) ä¿è¯æµ‹é‡çŸ©é˜µå¯¹ç¨€ç–ä¿¡å·çš„å‡ ä½•ç»“æ„ä¿æŒç¨³å®š\n$$ \\left(1-\\delta_{s}\\right)\\Vert \\nu\\Vert_{2}^{2}\\ \\leq\\ \\Vert\\mathbf{R}\\,\\nu\\Vert_{2}^{2}\\ \\leq\\ \\left(1+\\delta_{s}\\right)\\Vert\\nu\\Vert_{2}^{2} $$","date":"2025-11-19T00:00:00Z","image":"https://detail47.github.io/p/%E5%8E%8B%E7%BC%A9%E6%84%9F%E7%9F%A5/eLnOuUWj6iMTxmh_hu_dc62240c16c71863.webp","permalink":"https://detail47.github.io/p/%E5%8E%8B%E7%BC%A9%E6%84%9F%E7%9F%A5/","title":"å‹ç¼©æ„ŸçŸ¥"},{"content":"SARå‡ ä½• å‚è€ƒæ–¹å‘ $x$: azimuth ä¼ æ„Ÿå™¨çš„é£è¡Œæ–¹å‘ï¼Œä¹Ÿç§°ä¸ºæ²¿è½¨é“æ–¹å‘ $r$: range å¤©çº¿çš„è§†çº¿ï¼ˆLOSï¼‰æ–¹å‘ï¼Œä¹Ÿç§°ä¸ºå€¾æ–œèŒƒå›´ $\\theta$: elevation angle é«˜ç¨‹è§’ï¼Œå³å‚ç›´äºæ–¹ä½è§’å¹³é¢ã€‚é«˜ç¨‹$s$ åˆ†è¾¨ç‡ é£è¡Œæ–¹å‘ $$ \\rho_x = \\frac{\\lambda r}{2\\Delta x} $$è§†çº¿æ–¹å‘ $$ \\rho_r = \\frac{c}{2W} $$é«˜ç¨‹æ–¹å‘ï¼ˆTomoSARï¼‰ $$ \\rho_s = = \\frac{\\lambda r}{2\\Delta b} $$SARåŸç† å®é™…å­”å¾„å¤©çº¿ é˜µåˆ—å¤©çº¿é•¿$L$ï¼Œå‡åŒ€åŠ æƒã€‚å·¥ä½œæ³¢é•¿$\\lambda$ ï¼Œç›®æ ‡åç¦»è§†è½´è§’åº¦$\\theta$ï¼Œ$x$ä¸ºæ¥æ”¶ç‚¹åç¦»ç›¸ä½åŸºå‡†ç‚¹çš„ä½ç½®ã€‚å›æ³¢ä¿¡å·å•ç¨‹ç›¸ä½å·®ï¼š\n$$ \\varphi(x) = \\frac{2\\pi}{\\lambda}xsin\\theta $$å¤©çº¿æ–¹å‘å›¾å‡½æ•°ï¼š\n$$ F(\\theta)=\\frac{1}{L}\\int^{L/2}_{-L/2}e^{j\\varphi(x)}dx=\\frac{sin(\\frac{\\pi}{\\lambda}Lsin\\theta)}{\\frac{\\pi}{\\lambda}Lsin\\theta} $$æ”¶å‘åŒç¨‹åŠåŠŸç‡ç‚¹åˆ†è¾¨ç‡ï¼š\n$$ \\delta r_c|_{3dB}(åŒç¨‹)\\approx 0.64\\frac{\\lambda r}{L} $$ç¦»æ•£é˜µå…ƒé˜µåˆ—å¤©çº¿æ–¹å‘å›¾å‡½æ•°ï¼š\n$$ F(\\theta)=\\frac{sin[\\frac{\\pi Nd}{\\lambda}sin\\theta]}{Nsin(\\frac{\\pi d}{\\lambda}sin\\theta)} $$éèšç„¦ åŒç¨‹ç›¸ä½å·®ï¼š\n$$ \\varphi(x)=\\frac{4\\pi}{\\lambda}xsin\\theta \\approx \\frac{4\\pi v_pTy}{\\lambda r} $$å¤©çº¿æ–¹å‘å›¾å‡½æ•°ï¼š\n$$ F(\\theta)=\\frac{sin\\frac{2\\pi v_pTy}{\\lambda r}}{\\frac{2\\pi v_pTy}{\\lambda r}}\\quad\\quad y=r\\theta $$$\\frac{2}{\\pi}$å¹…åº¦å¤„å®šä¹‰çš„ç‘åˆ©åˆ†è¾¨ç‡ï¼š\n$$ \\delta\\gamma_\\alpha=\\frac{\\lambda r}{2L}\\quad\\quad L=v_pT $$åœ¨éèšç„¦å¤„ç†æ—¶ï¼Œé˜µé¢ä¸Šä¿¡å·çš„ç›¸ä½å·®å°†å½±å“åˆæˆå­”å¾„å¤©çº¿æ³¢æŸå±•å®½å’Œ å‰¯ç“£æ¶åŒ–ï¼Œä¸ºæ­¤ï¼Œå­”å¾„$L$å—åˆ°é™åˆ¶ï¼š$L_{max}=\\sqrt{\\lambda r}$ï¼Œè¿™æ—¶$\\Delta r \\le \\frac{\\lambda}{8}$ã€‚\néèšç„¦å¤„ç†çš„åˆ†è¾¨ç‡ $$ \\delta\\gamma_\\alpha=\\frac{1}{2}\\sqrt{\\lambda r} $$èšç„¦ èšç„¦å¤„ç†æ—¶ï¼Œé™„åŠ ç›¸ä½é¡¹å¯ä»¥åœ¨ä¿¡å·å¤„ç†è¿‡ç¨‹ä¸­äºˆä»¥è¡¥å¿ï¼Œæ•…æ­¤æ—¶åˆæˆå­”å¾„çš„é•¿åº¦å¯ç”±å®é™…å¤©çº¿æ³¢æŸå®½åº¦æ‰€èƒ½è¦†ç›–çš„é•¿åº¦$L_e$æ‰€å†³å®šã€‚ æœ‰æ•ˆé˜µåˆ—é•¿åº¦$L_e$ï¼Œå¤©çº¿æ³¢æŸå®½åº¦$\\theta_B$ï¼š\n$$ \\begin{align} L_e \u0026= r\\cdot \\theta_B\\\\ \\theta_B \u0026=\\frac\\lambda D \\end{align} $$èšç„¦å¤„ç†çš„åˆ†è¾¨ç‡ $$ \\delta\\gamma_\\alpha=\\frac{D}{2} $$","date":"2025-07-15T00:00:00Z","image":"https://detail47.github.io/p/sar%E5%87%A0%E4%BD%95/SAR_hu_d3caf1a5c17edc30.jpg","permalink":"https://detail47.github.io/p/sar%E5%87%A0%E4%BD%95/","title":"SARå‡ ä½•"},{"content":"åŸç†å›¾ ä¸‹å›¾ç”µè·¯ä¸ºå¼‚æ­¥Buckç”µè·¯ï¼Œå°†å›¾ä¸­äºŒæç®¡æ›´æ¢ä¸ºMOSç®¡åˆ™ä¸ºåŒæ­¥Buckç”µè·¯ã€‚ å¼€å…³å¯¼é€š å¼€å…³å¯¼é€šæ—¶ï¼ŒäºŒæç®¡ä¸å¯¼é€šï¼Œç”µæ„Ÿ$\\frac{\\mathrm{d}i}{\\mathrm{d}t}=\\frac{V_i-V_o}{L}$ä¸ºä¸€å¸¸æ•°ã€‚ç”µæµåŸºæœ¬å‘ˆçº¿æ€§å¢å¤§ã€‚\nå¼€å…³æ–­å¼€ å¼€å…³æ–­å¼€æ—¶ï¼ŒäºŒæç®¡å¯¼é€šï¼Œç”µæ„Ÿ$\\frac{\\mathrm{d}i}{\\mathrm{d}t}=-\\frac{V_d+V_o}{L}$ä¸ºä¸€å¸¸æ•°ã€‚ç”µæµåŸºæœ¬å‘ˆçº¿æ€§å‡å°ã€‚\nè®¾è®¡ç›®æ ‡ å·²çŸ¥æ¡ä»¶ è¾“å…¥ç”µå‹ $V_i$ è¾“å‡ºç”µå‹ $V_o$ å¼€å…³é¢‘ç‡ $f$ è¾“å…¥çº¹æ³¢è¦æ±‚ $\\Delta V_i$ è¾“å‡ºçº¹æ³¢è¦æ±‚ $\\Delta V_o$ è´Ÿè½½ç”µé˜» $R$ æ±‚è§£å€¼ ç”µæ„Ÿé‡ $L$ è¾“å…¥æ»¤æ³¢ç”µå®¹ $C_i$ è¾“å‡ºæ»¤æ³¢ç”µå®¹ $C_o$ è®¾è®¡è®¡ç®— å ç©ºæ¯” åœ¨ä¸€ä¸ªå‘¨æœŸå†…ç”µæ„Ÿç”µæµå¢åŠ é‡å’Œå‡å°‘é‡åº”ä¸€è‡´ã€‚æ ¹æ®ä¸Šæ–‡å¼€å…³æ‰“å¼€ä¸å…³é—­æ—¶ï¼Œç”µæ„Ÿç”µæµå¯¹æ—¶é—´çš„å¯¼æ•°çš„è¡¨è¾¾å¼å¯å¾—ä¸‹å¼ï¼š\n$$ \\frac{T_{on}}{T_{off}}=\\frac{V_o+V_d}{V_i-V_o} $$å˜æ¢å¾—åˆ°ä¼ç§’æ³•åˆ™ï¼š\n$$ \\begin{gather} V_{L_{on}}\\cdot T_{on}=V_{L_{off}}\\cdot T_{off}\\\\ å…¶ä¸­ \\begin{cases} V_{L_{on}}\u0026=V_i-V_o\\\\ V_{L_{off}}\u0026=V_o+V_d \\end{cases} \\end{gather} $$å†æ ¹æ®$T=T_{on}+T_{off}=\\frac1T$å¾—ï¼š $$ \\begin{align} \u0026\\begin{cases} T_{on}=\\frac{V_o+V_d}{V_i+V_d}\\cdot\\frac1f \\\\ T_{off}=\\frac{V_i-V_o}{V_i+V_d}\\cdot\\frac1f\\\\ \\end{cases}\\\\ \u0026D=\\frac{T_{on}}T=\\frac{V_o+V_d}{V_i+V_d}\\qquad å¯¹äºåŒæ­¥Buck:\\ V_d=0 \\end{align} $$ç”µæ„Ÿé€‰å‹ åœ¨ç”µæ„Ÿçš„é€‰æ‹©ä¸Šéœ€è¦è€ƒè™‘ä¸¤ä¸ªå‚æ•°\nç”µæ„Ÿæ„Ÿé‡ $L$ ç”µæ„Ÿç”µæµ $I_L$ å¹³å‡ç”µæµ $I_L^*$ çº¹æ³¢ç”µæµ $\\Delta I_L$ ä¸ºä¿è¯è¾“å‡ºç”µå®¹ç”µå‹æ’å®šï¼š $$ I_L=I_o=\\frac{V_o}R $$å¼€å…³å¯¼é€šæ—¶$U=V_i-V_o$ å¯¼é€šæ—¶é—´$\\Delta t=T_{on}=\\frac{V_o+V_d}{V_i+V_d}\\cdot\\frac1f$ å› æ­¤$\\Delta I_L = U \\cdot \\frac{\\Delta t}L=\\frac{V_o+V_d}{V_i+V_d}\\cdot\\frac1{f\\cdot L}\\cdot (V_i-V_o)$ å³ï¼š\n$$ \\Delta I_L=\\frac{V_o+V_d}{f\\cdot L}\\cdot\\frac{V_i-V_o}{V_i+V_d}\\qquad å¯¹äºåŒæ­¥Buck:\\ \\Delta I_L=\\frac{V_o}{f\\cdot L}\\cdot(1-\\frac{V_o}{V_i}) $$ç”µæ„Ÿå³°å€¼ç”µæµ$I_{LP}=I_o +\\frac{\\Delta I_L}2$ï¼Œåœ¨è®¾è®¡ä¸­è¦ç•™æœ‰ä¸€å®šä½™é‡ å³ï¼š\n$$ \\begin{align} \u0026I_{LP}=I_o+\\frac{V_o+V_d}{2\\cdot f\\cdot L}\\cdot\\frac{V_i-V_o}{V_i+V_d}\\\\ \u0026å¯¹äºåŒæ­¥Buck:\\ I_{LP}=I_o+\\frac{V_o}{2\\cdot f\\cdot L}\\cdot(1-\\frac{V_o}{V_i}) \\end{align} $$åœ¨è®¾è®¡ä¸­ç”µæ„Ÿçº¹æ³¢ç”µæµ$\\Delta I_L$åº”è¯¥æ˜¯$I_L$çš„ ==20%~40%== ä¸ºå®œï¼Œå³$\\Delta I_L=(0.2\\sim 0.4)\\cdot I_L$ å› æ­¤å³å¯å¾—å‡ºç”µæ„Ÿçš„æ„Ÿå€¼ï¼š\n$$ \\begin{align} \u0026L=\\frac{V_o+V_d}{f\\cdot(0.2\\sim 0.4)\\cdot I_o}\\cdot\\frac{V_i-V_o}{V_i+V_d}\\\\ \u0026å¯¹äºåŒæ­¥Buck:\\ L=\\frac{V_o}{f\\cdot(0.2\\sim 0.4)\\cdot I_o}\\cdot(1-\\frac{V_o}{V_i}) \\end{align} $$è¾“å…¥æ»¤æ³¢ç”µå®¹ å®é™…åº”ç”¨ä¸­ï¼Œè¾“å…¥ç”µæºåˆ°Buckç”µè·¯é—´æœ‰è¾ƒé•¿çš„å¯¼çº¿ï¼Œå¯¼çº¿æœ‰å¯„ç”Ÿç”µæ„Ÿã€‚å¯¼è‡´ç”µæºå¯¹è¾“å…¥çš„å“åº”ä¸èƒ½è¾¾åˆ°Buckç”µè·¯éœ€æ±‚ï¼Œå› æ­¤éœ€è¦é€‰æ‹©åˆé€‚çš„è¾“å…¥ç”µå®¹ã€‚\n","date":"2024-12-08T00:00:00Z","permalink":"https://detail47.github.io/p/buck%E7%94%B5%E8%B7%AF/","title":"Buckç”µè·¯"},{"content":"PIDæ¦‚è¿° æ¿€åŠ±ä¸ºç³»ç»Ÿè¾“å…¥ä¸è¾“å‡ºä¹‹å·®\n$$ e(t)=R_{in}(t)-Y{out}(t) $$PIDå…¬å¼ $$ u(t)=K_p\\cdot err(t)+K_i\\int_{0}^{t}err(t)\\,dx+K_d\\frac{d\\,err(t)}{dt} $$$$ u(t)=K_c\\,[e(t)+\\frac{1}{T_i}\\int_{0}^{t}e(t)\\,dt+T_d\\frac{d\\,e(t)}{dt}] $$æœ‰:\n$$ K_i=\\frac{K_c}{T_i} $$$$ K_d=K_c\\cdot T_d $$Ziegler-Nicholsæ–¹æ³• å…ˆç»™å®šä¸€ä¸ª$K_{cr}$ï¼ˆæ§åˆ¶å™¨å¢ç›Šï¼‰å€¼ï¼Œä½¿ç³»ç»Ÿå¤„äºä¸´ç•Œéœ‡è¡ã€‚ æµ‹å®šç³»ç»Ÿéœ‡è¡å‘¨æœŸ$T_{cr}$ è®¡ç®—å¾—åˆ°$K_c$ã€$T_i$å’Œ$T_d$çš„å€¼ åŸºäºä¸Šä¸€æ­¥å¾—åˆ°çš„å€¼å¾®è°ƒå‚æ•° æ§åˆ¶æ–¹å¼ $K_c$ $T_i$ $T_d$ P $0.5K_{cr}$ $\\infty$ $0$ PI $0.45K_{cr}$ $0.83T_{cr}$ $0$ PD $0.8K_{cr}$ $\\infty$ $0.12T_{cr}$ PID $0.6K_{cr}$ $0.5T_{cr}$ $0.12T_{cr}$ ä»¥$0.5K_{cr}$ä¸ºåŸºç¡€\nå¢å¤§$K_i$ï¼ˆå³å‡å°$T_i$ï¼‰ï¼Œéœ€å¾®è°ƒå¢å¤§$K_c$ å¢å¤§$K_d$ï¼ˆå³å¢å¤§$T_d$ï¼‰ï¼Œéœ€å¾®è°ƒå‡å°$K_c$ ","date":"2024-12-08T00:00:00Z","permalink":"https://detail47.github.io/p/pid/","title":"PID"},{"content":"SPIç®€ä»‹ SPIï¼ˆSerial Peripheral Interfaceï¼‰æ˜¯ç”±Motorolaå…¬å¸å¼€å‘çš„ä¸€ç§é€šç”¨æ•°æ®æ€»çº¿ å››æ ¹é€šä¿¡çº¿ï¼šSCKï¼ˆSerial Clockï¼‰ã€MOSIï¼ˆMaster Output Slave Inputï¼‰ã€MISOï¼ˆMaster Input Slave Outputï¼‰ã€SSï¼ˆSlave Selectï¼‰ åŒæ­¥ï¼Œå…¨åŒå·¥ æ”¯æŒæ€»çº¿æŒ‚è½½å¤šè®¾å¤‡ï¼ˆä¸€ä¸»å¤šä»ï¼‰ ç¡¬ä»¶ç”µè·¯ æ‰€æœ‰SPIè®¾å¤‡çš„SCKã€MOSIã€MISOåˆ†åˆ«è¿åœ¨ä¸€èµ· ä¸»æœºå¦å¤–å¼•å‡ºå¤šæ¡SSæ§åˆ¶çº¿ï¼Œåˆ†åˆ«æ¥åˆ°å„ä»æœºçš„SSå¼•è„š è¾“å‡ºå¼•è„šé…ç½®ä¸ºæ¨æŒ½è¾“å‡ºï¼Œè¾“å…¥å¼•è„šé…ç½®ä¸ºæµ®ç©ºæˆ–ä¸Šæ‹‰è¾“å…¥ SPIæ—¶åºå•å…ƒ èµ·å§‹æ¡ä»¶ï¼šSSä»é«˜ç”µå¹³åˆ‡æ¢åˆ°ä½ç”µå¹³ ç»ˆæ­¢æ¡ä»¶ï¼šSSä»ä½ç”µå¹³åˆ‡æ¢åˆ°é«˜ç”µå¹³ äº¤æ¢ä¸€ä¸ªå­—èŠ‚ï¼ˆæ¨¡å¼0ï¼‰ CPOL=0ï¼šç©ºé—²çŠ¶æ€æ—¶ï¼ŒSCKä¸ºä½ç”µå¹³ CPHA=0ï¼šSCKç¬¬ä¸€ä¸ªè¾¹æ²¿ç§»å…¥æ•°æ®ï¼Œç¬¬äºŒä¸ªè¾¹æ²¿ç§»å‡ºæ•°æ® äº¤æ¢ä¸€ä¸ªå­—èŠ‚ï¼ˆæ¨¡å¼1ï¼‰ CPOL=0ï¼šç©ºé—²çŠ¶æ€æ—¶ï¼ŒSCKä¸ºä½ç”µå¹³ CPHA=1ï¼šSCKç¬¬ä¸€ä¸ªè¾¹æ²¿ç§»å‡ºæ•°æ®ï¼Œç¬¬äºŒä¸ªè¾¹æ²¿ç§»å…¥æ•°æ® äº¤æ¢ä¸€ä¸ªå­—èŠ‚ï¼ˆæ¨¡å¼2ï¼‰ CPOL=1ï¼šç©ºé—²çŠ¶æ€æ—¶ï¼ŒSCKä¸ºé«˜ç”µå¹³ CPHA=0ï¼šSCKç¬¬ä¸€ä¸ªè¾¹æ²¿ç§»å…¥æ•°æ®ï¼Œç¬¬äºŒä¸ªè¾¹æ²¿ç§»å‡ºæ•°æ® äº¤æ¢ä¸€ä¸ªå­—èŠ‚ï¼ˆæ¨¡å¼3ï¼‰ CPOL=1ï¼šç©ºé—²çŠ¶æ€æ—¶ï¼ŒSCKä¸ºé«˜ç”µå¹³ CPHA=1ï¼šSCKç¬¬ä¸€ä¸ªè¾¹æ²¿ç§»å‡ºæ•°æ®ï¼Œç¬¬äºŒä¸ªè¾¹æ²¿ç§»å…¥æ•°æ® SPIæ—¶åº å‘é€æŒ‡ä»¤ å‘SSæŒ‡å®šçš„è®¾å¤‡ï¼Œå‘é€æŒ‡ä»¤ï¼ˆ0x06ï¼‰ æŒ‡å®šåœ°å€å†™ å‘SSæŒ‡å®šçš„è®¾å¤‡ï¼Œå‘é€å†™æŒ‡ä»¤ï¼ˆ0x02ï¼‰ï¼Œéšååœ¨æŒ‡å®šåœ°å€ï¼ˆAddress[23:0]ï¼‰ä¸‹ï¼Œå†™å…¥æŒ‡å®šæ•°æ®ï¼ˆDataï¼‰ æŒ‡å®šåœ°å€è¯» å‘SSæŒ‡å®šçš„è®¾å¤‡ï¼Œå‘é€è¯»æŒ‡ä»¤ï¼ˆ0x03ï¼‰ï¼Œéšååœ¨æŒ‡å®šåœ°å€ï¼ˆAddress[23:0]ï¼‰ä¸‹ï¼Œè¯»å–ä»æœºæ•°æ®ï¼ˆDataï¼‰ SPIå¤–è®¾ STM32å†…éƒ¨é›†æˆäº†ç¡¬ä»¶SPIæ”¶å‘ç”µè·¯ï¼Œå¯ä»¥ç”±ç¡¬ä»¶è‡ªåŠ¨æ‰§è¡Œæ—¶é’Ÿç”Ÿæˆã€æ•°æ®æ”¶å‘ç­‰åŠŸèƒ½ï¼Œå‡è½»CPUçš„è´Ÿæ‹… å¯é…ç½®8ä½/16ä½æ•°æ®å¸§ã€é«˜ä½å…ˆè¡Œ/ä½ä½å…ˆè¡Œ æ—¶é’Ÿé¢‘ç‡ï¼š fPCLK / (2, 4, 8, 16, 32, 64, 128, 256) æ”¯æŒå¤šä¸»æœºæ¨¡å‹ã€ä¸»æˆ–ä»æ“ä½œ å¯ç²¾ç®€ä¸ºåŠåŒå·¥/å•å·¥é€šä¿¡ æ”¯æŒDMA å…¼å®¹I2Såè®® å®é™…å¤–è®¾: STM32F103C8T6 ç¡¬ä»¶SPIèµ„æºï¼šSPI1ã€SPI2\nä»£ç  è½¯ä»¶SPI 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 void MySPI_W_SS(uint8_t BitValue) { GPIO_WriteBit(GPIOA, GPIO_Pin_4, (BitAction)BitValue); } void MySPI_W_SCK(uint8_t BitValue) { GPIO_WriteBit(GPIOA, GPIO_Pin_5, (BitAction)BitValue); } void MySPI_W_MOSI(uint8_t BitValue) { GPIO_WriteBit(GPIOA, GPIO_Pin_7, (BitAction)BitValue); } uint8_t MySPI_R_MISO(void) { return GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_6); } void MySPI_Init(void) { RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_7; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); MySPI_W_SS(1); MySPI_W_SCK(0); } void MySPI_Start(void) { MySPI_W_SS(0); } void MySPI_Stop(void) { MySPI_W_SS(1); } uint8_t MySPI_SwapByte(uint8_t ByteSend) { uint8_t i, ByteReceive = 0x00; for (i = 0; i \u0026lt; 8; i ++) { MySPI_W_MOSI(ByteSend \u0026amp; (0x80 \u0026gt;\u0026gt; i)); MySPI_W_SCK(1); if (MySPI_R_MISO() == 1){ByteReceive |= (0x80 \u0026gt;\u0026gt; i);} MySPI_W_SCK(0); } return ByteReceive; } ç¡¬ä»¶SPI å¾…å®Œæˆ\n","date":"2024-02-26T00:00:00Z","permalink":"https://detail47.github.io/p/stm32-spi/","title":"STM32 SPI"},{"content":"I2Cç®€ä»‹ I2Cï¼ˆInter IC Busï¼‰æ˜¯ç”±Philipså…¬å¸å¼€å‘çš„ä¸€ç§é€šç”¨æ•°æ®æ€»çº¿ ä¸¤æ ¹é€šä¿¡çº¿ï¼šSCLï¼ˆSerial Clockï¼‰ã€SDAï¼ˆSerial Dataï¼‰ åŒæ­¥ï¼ŒåŠåŒå·¥ å¸¦æ•°æ®åº”ç­” æ”¯æŒæ€»çº¿æŒ‚è½½å¤šè®¾å¤‡ï¼ˆä¸€ä¸»å¤šä»ã€å¤šä¸»å¤šä»ï¼‰ ç¡¬ä»¶ç”µè·¯ æ‰€æœ‰I2Cè®¾å¤‡çš„SCLè¿åœ¨ä¸€èµ·ï¼ŒSDAè¿åœ¨ä¸€èµ· è®¾å¤‡çš„SCLå’ŒSDAå‡è¦é…ç½®æˆå¼€æ¼è¾“å‡ºæ¨¡å¼ SCLå’ŒSDAå„æ·»åŠ ä¸€ä¸ªä¸Šæ‹‰ç”µé˜»ï¼Œé˜»å€¼ä¸€èˆ¬ä¸º4.7KÎ©å·¦å³ I2Cæ—¶åºåŸºæœ¬å•å…ƒ èµ·å§‹æ¡ä»¶ï¼šSCLé«˜ç”µå¹³æœŸé—´ï¼ŒSDAä»é«˜ç”µå¹³åˆ‡æ¢åˆ°ä½ç”µå¹³ ç»ˆæ­¢æ¡ä»¶ï¼šSCLé«˜ç”µå¹³æœŸé—´ï¼ŒSDAä»ä½ç”µå¹³åˆ‡æ¢åˆ°é«˜ç”µå¹³ å‘é€ä¸€ä¸ªå­—èŠ‚ï¼šSCLä½ç”µå¹³æœŸé—´ï¼Œä¸»æœºå°†æ•°æ®ä½ä¾æ¬¡æ”¾åˆ°SDAçº¿ä¸Šï¼ˆé«˜ä½å…ˆè¡Œï¼‰ï¼Œç„¶åé‡Šæ”¾SCLï¼Œä»æœºå°†åœ¨SCLé«˜ç”µå¹³æœŸé—´è¯»å–æ•°æ®ä½ï¼Œæ‰€ä»¥SCLé«˜ç”µå¹³æœŸé—´SDAä¸å…è®¸æœ‰æ•°æ®å˜åŒ–ï¼Œä¾æ¬¡å¾ªç¯ä¸Šè¿°è¿‡ç¨‹8æ¬¡ï¼Œå³å¯å‘é€ä¸€ä¸ªå­—èŠ‚ æ¥æ”¶ä¸€ä¸ªå­—èŠ‚ï¼šSCLä½ç”µå¹³æœŸé—´ï¼Œä»æœºå°†æ•°æ®ä½ä¾æ¬¡æ”¾åˆ°SDAçº¿ä¸Šï¼ˆé«˜ä½å…ˆè¡Œï¼‰ï¼Œç„¶åé‡Šæ”¾SCLï¼Œä¸»æœºå°†åœ¨SCLé«˜ç”µå¹³æœŸé—´è¯»å–æ•°æ®ä½ï¼Œæ‰€ä»¥SCLé«˜ç”µå¹³æœŸé—´SDAä¸å…è®¸æœ‰æ•°æ®å˜åŒ–ï¼Œä¾æ¬¡å¾ªç¯ä¸Šè¿°è¿‡ç¨‹8æ¬¡ï¼Œå³å¯æ¥æ”¶ä¸€ä¸ªå­—èŠ‚ï¼ˆä¸»æœºåœ¨æ¥æ”¶ä¹‹å‰ï¼Œéœ€è¦é‡Šæ”¾SDAï¼‰ å‘é€åº”ç­”ï¼šä¸»æœºåœ¨æ¥æ”¶å®Œä¸€ä¸ªå­—èŠ‚ä¹‹åï¼Œåœ¨ä¸‹ä¸€ä¸ªæ—¶é’Ÿå‘é€ä¸€ä½æ•°æ®ï¼Œæ•°æ®0è¡¨ç¤ºåº”ç­”ï¼Œæ•°æ®1è¡¨ç¤ºéåº”ç­” æ¥æ”¶åº”ç­”ï¼šä¸»æœºåœ¨å‘é€å®Œä¸€ä¸ªå­—èŠ‚ä¹‹åï¼Œåœ¨ä¸‹ä¸€ä¸ªæ—¶é’Ÿæ¥æ”¶ä¸€ä½æ•°æ®ï¼Œåˆ¤æ–­ä»æœºæ˜¯å¦åº”ç­”ï¼Œæ•°æ®0è¡¨ç¤ºåº”ç­”ï¼Œæ•°æ®1è¡¨ç¤ºéåº”ç­”ï¼ˆä¸»æœºåœ¨æ¥æ”¶ä¹‹å‰ï¼Œéœ€è¦é‡Šæ”¾SDAï¼‰ I2Cæ—¶åº æŒ‡å®šåœ°å€å†™ å¯¹äºæŒ‡å®šè®¾å¤‡ï¼ˆSlave Addressï¼‰ï¼Œåœ¨æŒ‡å®šåœ°å€ï¼ˆReg Addressï¼‰ä¸‹ï¼Œå†™å…¥æŒ‡å®šæ•°æ®ï¼ˆDataï¼‰\nå½“å‰åœ°å€è¯» å¯¹äºæŒ‡å®šè®¾å¤‡ï¼ˆSlave Addressï¼‰ï¼Œåœ¨å½“å‰åœ°å€æŒ‡é’ˆæŒ‡ç¤ºçš„åœ°å€ä¸‹ï¼Œè¯»å–ä»æœºæ•°æ®ï¼ˆDataï¼‰\næŒ‡å®šåœ°å€è¯» å¯¹äºæŒ‡å®šè®¾å¤‡ï¼ˆSlave Addressï¼‰ï¼Œåœ¨æŒ‡å®šåœ°å€ï¼ˆReg Addressï¼‰ä¸‹ï¼Œè¯»å–ä»æœºæ•°æ®ï¼ˆDataï¼‰\nI2Cå¤–è®¾ STM32å†…éƒ¨é›†æˆäº†ç¡¬ä»¶I2Cæ”¶å‘ç”µè·¯ï¼Œå¯ä»¥ç”±ç¡¬ä»¶è‡ªåŠ¨æ‰§è¡Œæ—¶é’Ÿç”Ÿæˆã€èµ·å§‹ç»ˆæ­¢æ¡ä»¶ç”Ÿæˆã€åº”ç­”ä½æ”¶å‘ã€æ•°æ®æ”¶å‘ç­‰åŠŸèƒ½ï¼Œå‡è½»CPUçš„è´Ÿæ‹… æ”¯æŒå¤šä¸»æœºæ¨¡å‹ æ”¯æŒ7ä½/10ä½åœ°å€æ¨¡å¼ æ”¯æŒä¸åŒçš„é€šè®¯é€Ÿåº¦ï¼Œæ ‡å‡†é€Ÿåº¦(é«˜è¾¾100 kHz)ï¼Œå¿«é€Ÿ(é«˜è¾¾400 kHz) æ”¯æŒDMA å…¼å®¹SMBusåè®® å®é™…å¤–è®¾: STM32F103C8T6 ç¡¬ä»¶I2Cèµ„æºï¼šI2C1ã€I2C2\nåºåˆ—å›¾ ä»£ç  è½¯ä»¶I2C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 /*ç¡¬ä»¶*/ // SCLå†™ void MyI2C_W_SCL(uint8_t BitValue){ GPIO_WriteBit(GPIOB, GPIO_Pin_10, (BitAction)BitValue); Delay_us(10); } // SDAå†™ void MyI2C_W_SDA(uint8_t BitValue){ GPIO_WriteBit(GPIOB, GPIO_Pin_11, (BitAction)BitValue); Delay_us(10); } // SDAè¯» uint8_t MyI2C_R_SDA(void) { uint8_t BitValue; BitValue = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11); Delay_us(10); return BitValue; } //GPIOé…ç½® void MyI2C_Init(void) { RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, \u0026amp;GPIO_InitStructure); GPIO_SetBits(GPIOB, GPIO_Pin_10 | GPIO_Pin_11); } /*åè®®*/ //å¼€å§‹æ ‡å¿— void MyI2C_Start(void){ MyI2C_W_SDA(1); MyI2C_W_SCL(1); MyI2C_W_SDA(0); MyI2C_W_SCL(0); } //ç»“æŸæ ‡å¿— void MyI2C_Stop(void) { MyI2C_W_SDA(0); MyI2C_W_SCL(1); MyI2C_W_SDA(1); } //å‘é€æ•°æ® void MyI2C_SendByte(uint8_t Byte){ uint8_t i; for (i = 0; i \u0026lt; 8; i ++) { MyI2C_W_SDA(Byte \u0026amp; (0x80 \u0026gt;\u0026gt; i)); MyI2C_W_SCL(1); MyI2C_W_SCL(0); } } //æ¥æ”¶æ•°æ® uint8_t MyI2C_ReceiveByte(void){ uint8_t i, Byte = 0x00; MyI2C_W_SDA(1); for (i = 0; i \u0026lt; 8; i ++) { MyI2C_W_SCL(1); if (MyI2C_R_SDA() == 1){ Byte |= (0x80 \u0026gt;\u0026gt; i); } MyI2C_W_SCL(0); } return Byte; } //åº”ç­”ä¿¡å·å‘é€ void MyI2C_SendAck(uint8_t AckBit) { MyI2C_W_SDA(AckBit); MyI2C_W_SCL(1); MyI2C_W_SCL(0); } //åº”ç­”ä¿¡å·æ¥æ”¶ uint8_t MyI2C_ReceiveAck(void) { uint8_t AckBit; MyI2C_W_SDA(1); MyI2C_W_SCL(1); AckBit = MyI2C_R_SDA(); MyI2C_W_SCL(0); return AckBit; } ç¡¬ä»¶I2C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 //ç¡¬ä»¶åœ°å€ #define ADDRESS 0xD0 //æ—¶é’Ÿé…ç½® RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); //GPIOé…ç½® GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, \u0026amp;GPIO_InitStructure); //I2Cé…ç½® I2C_InitTypeDef I2C_InitStructure; I2C_InitStructure.I2C_Mode = I2C_Mode_I2C; I2C_InitStructure.I2C_ClockSpeed = 50000; I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2; I2C_InitStructure.I2C_Ack = I2C_Ack_Enable; I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit; I2C_InitStructure.I2C_OwnAddress1 = 0x00; I2C_Init(I2C2, \u0026amp;I2C_InitStructure); //I2Cä½¿èƒ½ I2C_Cmd(I2C2, ENABLE); //ç­‰å¾…äº‹ä»¶ void I2C_WaitEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT) { uint32_t Timeout; Timeout = 10000; while (I2C_CheckEvent(I2Cx, I2C_EVENT) != SUCCESS) { Timeout --; if (Timeout == 0){ /*è¶…æ—¶çš„é”™è¯¯å¤„ç†ä»£ç ï¼Œå¯ä»¥æ·»åŠ åˆ°æ­¤å¤„*/ break; } } } void I2C_WriteReg(uint8_t RegAddress, uint8_t Data) { I2C_GenerateSTART(I2C2, ENABLE); I2C_WaitEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT); I2C_Send7bitAddress(I2C2, ADDRESS, I2C_Direction_Transmitter); I2C_WaitEvent(I2C2, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED); I2C_SendData(I2C2, RegAddress); I2C_WaitEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTING); I2C_SendData(I2C2, Data); I2C_WaitEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTED); I2C_GenerateSTOP(I2C2, ENABLE); } uint8_t I2C_ReadReg(uint8_t RegAddress) { uint8_t Data; I2C_GenerateSTART(I2C2, ENABLE); I2C_WaitEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT); I2C_Send7bitAddress(I2C2, ADDRESS, I2C_Direction_Transmitter); I2C_WaitEvent(I2C2, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED); I2C_SendData(I2C2, RegAddress); I2C_WaitEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTED); I2C_GenerateSTART(I2C2, ENABLE); I2C_WaitEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT); I2C_Send7bitAddress(I2C2, ADDRESS, I2C_Direction_Receiver); I2C_WaitEvent(I2C2, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED); I2C_AcknowledgeConfig(I2C2, DISABLE); I2C_GenerateSTOP(I2C2, ENABLE); I2C_WaitEvent(I2C2, I2C_EVENT_MASTER_BYTE_RECEIVED); Data = I2C_ReceiveData(I2C2); I2C_AcknowledgeConfig(I2C2, ENABLE); return Data; } I2C_InitTypeDefä¸ºI2Cé…ç½®ç»“æ„ä½“ I2C_Modeä¸ºI2Cæ¨¡å¼ I2C_ClockSpeedä¸ºæ—¶é’Ÿé¢‘ç‡ I2C_DutyCycleä¸ºI2Cå¿«é€Ÿæ¨¡å¼å ç©ºæ¯” I2C_Ackä¸ºå“åº”ä½¿èƒ½ I2C_AcknowledgedAddressä¸ºåœ°å€æ¨¡å¼ I2C_OwnAddress1ä¸ºæœ¬è®¾å¤‡çš„ç¬¬ä¸€ä¸ªID I2C_GenerateSTARTå‡½æ•°å‘é€èµ·å§‹æ¡ä»¶ I2C_Send7bitAddresså‡½æ•°å‘é€7ä½åœ°å€ I2C_SendDataå‡½æ•°å‘é€æ•°æ® I2C_GenerateSTOPå‡½æ•°å‘é€ç»ˆæ­¢æ¡ä»¶ I2C_AcknowledgeConfigå‡½æ•°é…ç½®åº”ç­” I2C_CheckEventå‡½æ•°è¯»å–çŠ¶æ€ I2C_ReceiveDataå‡½æ•°è¯»å–ç»“æœ I2C_EVENT äº‹ä»¶ å€¼ I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED EV1 ((uint32_t)0x00060082) I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED EV1 ((uint32_t)0x00020002) I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED EV1 ((uint32_t)0x00860080) I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED EV1 ((uint32_t)0x00820000) I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED EV1 ((uint32_t)0x00120000) I2C_EVENT_SLAVE_BYTE_RECEIVED EV2 ((uint32_t)0x00020040) (I2C_EVENT_SLAVE_BYTE_RECEIVED| I2C_FLAG_DUALF) EV2 (I2C_EVENT_SLAVE_BYTE_RECEIVED| I2C_FLAG_GENCALL) EV2 I2C_EVENT_SLAVE_BYTE_TRANSMITTED EV3 ((uint32_t)0x00060084) (I2C_EVENT_SLAVE_BYTE_TRANSMITTED| I2C_FLAG_DUALF) EV3 (I2C_EVENT_SLAVE_BYTE_TRANSMITTED| I2C_FLAG_GENCALL) EV3 I2C_EVENT_SLAVE_ACK_FAILURE EV3_2 ((uint32_t)0x00000400) I2C_EVENT_SLAVE_STOP_DETECTED EV4 ((uint32_t)0x00000010) I2C_EVENT_MASTER_MODE_SELECT EV5 I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED EV6 I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED EV6 I2C_EVENT_MASTER_BYTE_RECEIVED EV7 I2C_EVENT_MASTER_BYTE_TRANSMITTING EV8 I2C_EVENT_MASTER_BYTE_TRANSMITTED EV8_2 I2C_EVENT_MASTER_MODE_ADDRESS10 EV9 I2Cäº‹ä»¶æµç¨‹ï¼ˆå¸¸ç”¨çš„ä¸»æ¨¡å¼ï¼‰ é€šè®¯å¼€å§‹ EV5 I2C_EVENT_MASTER_MODE_SELECT After sending the START condition (I2C_GenerateSTART() function) the master has to wait for this event. It means that the Start condition has been correctly released on the I2C bus (the bus is free, no other devices is communicating). å‘é€ é€šè®¯å¯åŠ¨æ¡ä»¶ï¼ˆI2C_GenerateSTART() å‡½æ•°ï¼‰åï¼Œä¸»è®¾å¤‡å¿…é¡»ç­‰å¾…æ­¤äº‹ä»¶ï¼ˆEV5ï¼‰ã€‚ æ­¤äº‹ä»¶æ„å‘³ç€I2Cæ€»çº¿ä¸Šçš„å¯åŠ¨æ¡ä»¶å·²æ­£ç¡®é‡Šæ”¾ï¼ˆæ€»çº¿ç©ºé—²ï¼Œæ²¡æœ‰å…¶ä»–è®¾å¤‡æ­£åœ¨é€šä¿¡ï¼‰ã€‚ åœ°å€ç¡®è®¤ EV6 I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED After checking on EV5 (start condition correctly released on the bus), the master sends the address of the slave(s) with which it will communicate (I2C_Send7bitAddress() function, it also determines the direction of the communication: Master transmitter or Receiver). Then the master has to wait that a slave acknowledges his address. If an acknowledge is sent on the bus, one of the following events will be set: In case of Master Receiver (7-bit addressing): the I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED event is set. In case of Master Transmitter (7-bit addressing): the I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED is set In case of 10-Bit addressing mode, the master (just after generating the START and checking on EV5) has to send the header of 10-bit addressing mode (I2C_SendData() function). Then master should wait on EV9. It means that the 10-bit addressing header has been correctly sent on the bus. Then master should send the second part of the 10-bit address (LSB) using the function I2C_Send7bitAddress(). Then master should wait for event EV6. ä¸»è®¾å¤‡å‘é€ä¸å…¶é€šä¿¡çš„ä»è®¾å¤‡çš„åœ°å€ï¼ŒåŒæ—¶ç¡®å®šé€šä¿¡æ–¹å‘ï¼Œç„¶åä¸»è®¾å¤‡åº”è¯¥ç­‰å¾…äº‹ä»¶EV6ã€‚ é€šè®¯äº‹ä»¶ EV8ã€EV8_2 / EV7 I2C_EVENT_MASTER_BYTE_TRANSMITTINGã€I2C_EVENT_MASTER_BYTE_TRANSMITTED / I2C_EVENT_MASTER_BYTE_RECEIVED Others If a communication is established (START condition generated and slave address acknowledged) then the master has to check on one of the following events for communication procedures:\nMaster Receiver mode: The master has to wait on the event EV7 then to read the data received from the slave (I2C_ReceiveData() function). Master Transmitter mode: The master has to send data (I2C_SendData() function) then to wait on event EV8 or EV8_2. These two events are similar: EV8 means that the data has been written in the data register and is being shifted out. EV8_2 means that the data has been physically shifted out and output on the bus. In most cases, using EV8 is sufficient for the application. Using EV8_2 leads to a slower communication but ensure more reliable test. EV8_2 is also more suitable than EV8 for testing on the last data transmission (before Stop condition generation). In case the user software does not guarantee that this event EV7 is managed before the current byte end of transfer, then user may check on EV7 and BTF flag at the same time (ie. (I2C_EVENT_MASTER_BYTE_RECEIVED | I2C_FLAG_BTF)). In this case the communication may be slower. ","date":"2024-02-20T00:00:00Z","permalink":"https://detail47.github.io/p/stm32-i2c/","title":"STM32 I2C"},{"content":"DMAç®€ä»‹ DMAï¼ˆDirect Memory Accessï¼‰ç›´æ¥å­˜å‚¨å™¨å­˜å– DMAå¯ä»¥æä¾›å¤–è®¾å’Œå­˜å‚¨å™¨æˆ–è€…å­˜å‚¨å™¨å’Œå­˜å‚¨å™¨ä¹‹é—´çš„é«˜é€Ÿæ•°æ®ä¼ è¾“ï¼Œæ— é¡»CPUå¹²é¢„ï¼ŒèŠ‚çœäº†CPUçš„èµ„æº 12ä¸ªç‹¬ç«‹å¯é…ç½®çš„é€šé“ï¼š DMA1ï¼ˆ7ä¸ªé€šé“ï¼‰ï¼Œ DMA2ï¼ˆ5ä¸ªé€šé“ï¼‰ æ¯ä¸ªé€šé“éƒ½æ”¯æŒè½¯ä»¶è§¦å‘å’Œç‰¹å®šçš„ç¡¬ä»¶è§¦å‘ STM32F103C8T6 DMAèµ„æºï¼šDMA1ï¼ˆ7ä¸ªé€šé“ï¼‰ DMAæ•°æ®ä¼ è¾“å®½åº¦ä¸å¤§å° DMAæ•°æ®ä¼ è¾“: æºç«¯å¤§äºç›®æ ‡ï¼Œé«˜ä½èˆå¼ƒã€‚ æºç«¯å°äºç›®æ ‡ï¼Œé«˜ä½è¡¥é›¶ã€‚\nä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 //å…¨å±€å˜é‡ï¼Œç”¨äºå­˜å‚¨æ¯æ¬¡è½¬è¿çš„å­—èŠ‚æ•° uint16_t MyDMA_Size; //é…ç½®æ—¶é’Ÿ RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE); //DMAé…ç½® DMA_InitTypeDef DMA_InitStructure; DMA_InitStructure.DMA_PeripheralBaseAddr = AddrA; DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte; DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable; DMA_InitStructure.DMA_MemoryBaseAddr = AddrB; DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte; DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC; DMA_InitStructure.DMA_BufferSize = Size; DMA_InitStructure.DMA_Mode = DMA_Mode_Normal; DMA_InitStructure.DMA_M2M = DMA_M2M_Enable; DMA_InitStructure.DMA_Priority = DMA_Priority_Medium; DMA_Init(DMA1_Channel1, \u0026amp;DMA_InitStructure); //DMAä½¿èƒ½ï¼ˆè¿™é‡Œæœªä½¿èƒ½ï¼‰ DMA_Cmd(DMA1_Channel1, DISABLE); void MyDMA_Transfer(void) { DMA_Cmd(DMA1_Channel1, DISABLE); DMA_SetCurrDataCounter(DMA1_Channel1, MyDMA_Size); DMA_Cmd(DMA1_Channel1, ENABLE); while (DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET); DMA_ClearFlag(DMA1_FLAG_TC1); } DMA_InitTypeDefä¸ºDMAé…ç½®ç»“æ„ä½“\nå¤–è®¾é…ç½®ï¼š DMA_PeripheralBaseAddrä¸ºå¤–è®¾åŸºåœ°å€ï¼Œè½¬è¿æ¥æº DMA_PeripheralDataSizeä¸ºå¤–è®¾æ•°æ®å®½åº¦ DMA_PeripheralIncä¸ºå¤–è®¾åœ°å€è‡ªå¢ï¼š DMA_PeripheralInc_Enableå¼€å¯ DMA_PeripheralInc_Disableå…³é—­ å­˜å‚¨å™¨é…ç½®ï¼š DMA_MemoryBaseAddrä¸ºå­˜å‚¨å™¨åŸºåœ°å€ï¼Œè½¬è¿ç›®æ ‡ DMA_MemoryDataSizeä¸ºå­˜å‚¨å™¨æ•°æ®å®½åº¦ DMA_MemoryIncä¸ºå­˜å‚¨å™¨åœ°å€è‡ªå¢ï¼š DMA_MemoryInc_Enableå¼€å¯ DMA_MemoryInc_Disableå…³é—­ DMA_DIRä¸ºæ•°æ®ä¼ è¾“æ–¹å‘ï¼š DMA_DIR_PeripheralDSTå­˜å‚¨å™¨åˆ°å¤–è®¾ DMA_DIR_PeripheralSRCå¤–è®¾åˆ°å­˜å‚¨å™¨ DMA_BufferSizeä¸ºè½¬è¿çš„æ•°æ®å¤§å°ï¼ˆè½¬è¿æ¬¡æ•°ï¼‰ DMA_Modeä¸ºæ¨¡å¼ï¼Œä¸»è¦é…ç½®è‡ªåŠ¨é‡è£… DMA_Mode_Circularå¾ªç¯æ¨¡å¼ DMA_Mode_Normalå•æ¬¡æ¨¡å¼ DMA_M2Mè½¯ç¡¬ä»¶è§¦å‘é€‰æ‹© DMA_M2M_Enableå¼€å¯ DMA_M2M_Disableå…³é—­ DMA_Priorityä¼˜å…ˆçº§ DMA_PeripheralDataSize å€¼ æè¿° DMA_PeripheralDataSize_Byte ((uint32_t)0x00000000) 1Byte DMA_PeripheralDataSize_HalfWord ((uint32_t)0x00000100) 2Byte DMA_PeripheralDataSize_Word ((uint32_t)0x00000200) 4Byte DMA_MemoryDataSize å€¼ æè¿° DMA_MemoryDataSize_Byte ((uint32_t)0x00000000) 1Byte DMA_MemoryDataSize_HalfWord ((uint32_t)0x00000400) 2Byte DMA_MemoryDataSize_Word ((uint32_t)0x00000800) 4Byte DMA_Priority å€¼ æè¿° DMA_Priority_VeryHigh ((uint32_t)0x00003000) éå¸¸é«˜ DMA_Priority_High ((uint32_t)0x00002000) é«˜ DMA_Priority_Medium ((uint32_t)0x00001000) ä¸­ DMA_Priority_Low ((uint32_t)0x00000000) ä½ DMA + ADC ååŒå·¥ä½œ DMAè¯·æ±‚ æ›´å¤šDMAè¯·æ±‚æ˜ åƒçš„ç›¸å…³å†…å®¹ï¼šSTM32F10xxxå‚è€ƒæ‰‹å†Œï¼ˆä¸­æ–‡ï¼‰.pdf é¡µç 147/æ‰‹å†Œ10.3.7\nä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 //å­˜å‚¨æ•°å€¼çš„å…¨å±€å˜é‡ uint16_t AD_Value[4]; //æ—¶é’Ÿé…ç½® RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE); RCC_ADCCLKConfig(RCC_PCLK2_Div6); //GPIOé…ç½® GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); //ADCé€šé“é…ç½® ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_55Cycles5); ADC_RegularChannelConfig(ADC1, ADC_Channel_1, 2, ADC_SampleTime_55Cycles5); ADC_RegularChannelConfig(ADC1, ADC_Channel_2, 3, ADC_SampleTime_55Cycles5); ADC_RegularChannelConfig(ADC1, ADC_Channel_3, 4, ADC_SampleTime_55Cycles5); //ADCé…ç½® ADC_InitTypeDef ADC_InitStructure; ADC_InitStructure.ADC_Mode = ADC_Mode_Independent; ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; ADC_InitStructure.ADC_ContinuousConvMode = ENABLE; ADC_InitStructure.ADC_ScanConvMode = ENABLE; ADC_InitStructure.ADC_NbrOfChannel = 4; ADC_Init(ADC1, \u0026amp;ADC_InitStructure); //DMAé…ç½® DMA_InitTypeDef DMA_InitStructure; DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)\u0026amp;ADC1-\u0026gt;DR; DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord; DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable; DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)AD_Value; DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord; DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC; MA_InitStructure.DMA_BufferSize = 4; DMA_InitStructure.DMA_Mode = DMA_Mode_Circular; DMA_InitStructure.DMA_M2M = DMA_M2M_Disable; DMA_InitStructure.DMA_Priority = DMA_Priority_Medium; DMA_Init(DMA1_Channel1, \u0026amp;DMA_InitStructure); //DMAå’ŒADCä½¿èƒ½ DMA_Cmd(DMA1_Channel1, ENABLE); ADC_DMACmd(ADC1, ENABLE); ADC_Cmd(ADC1, ENABLE); //ADCæ ¡å‡† ADC_ResetCalibration(ADC1); while (ADC_GetResetCalibrationStatus(ADC1) == SET); ADC_StartCalibration(ADC1); while (ADC_GetCalibrationStatus(ADC1) == SET); //ADCè§¦å‘ ADC_SoftwareStartConvCmd(ADC1, ENABLE); DMA_Cmd(DMA1_Channel1, ENABLE);å¯ç”¨DMAé€šé“1 ADC_DMACmd(ADC1, ENABLE);å¯ç”¨ADC1è§¦å‘DMA1ä¿¡å· ADC_Cmd(ADC1, ENABLE);å¯ç”¨ADC1 ","date":"2024-02-17T00:00:00Z","permalink":"https://detail47.github.io/p/stm32-dma/","title":"STM32 DMA"},{"content":"é€šä¿¡æ¥å£ é€šä¿¡çš„ç›®çš„ï¼šå°†ä¸€ä¸ªè®¾å¤‡çš„æ•°æ®ä¼ é€åˆ°å¦ä¸€ä¸ªè®¾å¤‡ï¼Œæ‰©å±•ç¡¬ä»¶ç³»ç»Ÿ é€šä¿¡åè®®ï¼šåˆ¶å®šé€šä¿¡çš„è§„åˆ™ï¼Œé€šä¿¡åŒæ–¹æŒ‰ç…§åè®®è§„åˆ™è¿›è¡Œæ•°æ®æ”¶å‘ åç§° å¼•è„š åŒå·¥ æ—¶é’Ÿ ç”µå¹³ è®¾å¤‡ USART TXã€RX å…¨åŒå·¥ å¼‚æ­¥ å•ç«¯ ç‚¹å¯¹ç‚¹ I2C SCLã€SDA åŠåŒå·¥ åŒæ­¥ å•ç«¯ å¤šè®¾å¤‡ SPI SCLKã€MOSIã€MISOã€CS å…¨åŒå·¥ åŒæ­¥ å•ç«¯ å¤šè®¾å¤‡ CAN CAN_Hã€CAN_L åŠåŒå·¥ å¼‚æ­¥ å·®åˆ† å¤šè®¾å¤‡ USB DPã€DM åŠåŒå·¥ å¼‚æ­¥ å·®åˆ† ç‚¹å¯¹ç‚¹ ä¸²å£ ä¸²å£æ˜¯ä¸€ç§åº”ç”¨ååˆ†å¹¿æ³›çš„é€šè®¯æ¥å£ï¼Œä¸²å£æˆæœ¬ä½ã€å®¹æ˜“ä½¿ç”¨ã€é€šä¿¡çº¿è·¯ç®€å•ï¼Œå¯å®ç°ä¸¤ä¸ªè®¾å¤‡çš„äº’ç›¸é€šä¿¡ å•ç‰‡æœºçš„ä¸²å£å¯ä»¥ä½¿å•ç‰‡æœºä¸å•ç‰‡æœºã€å•ç‰‡æœºä¸ç”µè„‘ã€å•ç‰‡æœºä¸å„å¼å„æ ·çš„æ¨¡å—äº’ç›¸é€šä¿¡ï¼Œæå¤§åœ°æ‰©å±•äº†å•ç‰‡æœºçš„åº”ç”¨èŒƒå›´ï¼Œå¢å¼ºäº†å•ç‰‡æœºç³»ç»Ÿçš„ç¡¬ä»¶å®åŠ› ç¡¬ä»¶ç”µè·¯ ç®€å•åŒå‘ä¸²å£é€šä¿¡æœ‰ä¸¤æ ¹é€šä¿¡çº¿ï¼ˆå‘é€ç«¯TXå’Œæ¥æ”¶ç«¯RXï¼‰ TXä¸RXè¦äº¤å‰è¿æ¥ å½“åªéœ€å•å‘çš„æ•°æ®ä¼ è¾“æ—¶ï¼Œå¯ä»¥åªæ¥ä¸€æ ¹é€šä¿¡çº¿ å½“ç”µå¹³æ ‡å‡†ä¸ä¸€è‡´æ—¶ï¼Œéœ€è¦åŠ ç”µå¹³è½¬æ¢èŠ¯ç‰‡ ç”µå¹³æ ‡å‡† ç”µå¹³æ ‡å‡†æ˜¯æ•°æ®1å’Œæ•°æ®0çš„è¡¨è¾¾æ–¹å¼ï¼Œæ˜¯ä¼ è¾“çº¿ç¼†ä¸­äººä¸ºè§„å®šçš„ç”µå‹ä¸æ•°æ®çš„å¯¹åº”å…³ç³»ï¼Œä¸²å£å¸¸ç”¨çš„ç”µå¹³æ ‡å‡†æœ‰å¦‚ä¸‹ä¸‰ç§ï¼š\nTTLç”µå¹³ï¼š+3.3Væˆ–+5Vè¡¨ç¤º1ï¼Œ0Vè¡¨ç¤º0 RS232ç”µå¹³ï¼š-3~-15Vè¡¨ç¤º1ï¼Œ+3~+15Vè¡¨ç¤º0 RS485ç”µå¹³ï¼šä¸¤çº¿å‹å·®+2~+6Vè¡¨ç¤º1ï¼Œ-2~-6Vè¡¨ç¤º0ï¼ˆå·®åˆ†ä¿¡å·ï¼‰ ä¸²å£å‚æ•°åŠæ—¶åº æ³¢ç‰¹ç‡ï¼šä¸²å£é€šä¿¡çš„é€Ÿç‡ èµ·å§‹ä½ï¼šæ ‡å¿—ä¸€ä¸ªæ•°æ®å¸§çš„å¼€å§‹ï¼Œå›ºå®šä¸ºä½ç”µå¹³ æ•°æ®ä½ï¼šæ•°æ®å¸§çš„æœ‰æ•ˆè½½è·ï¼Œ1ä¸ºé«˜ç”µå¹³ï¼Œ0ä¸ºä½ç”µå¹³ï¼Œä½ä½å…ˆè¡Œ æ ¡éªŒä½ï¼šç”¨äºæ•°æ®éªŒè¯ï¼Œæ ¹æ®æ•°æ®ä½è®¡ç®—å¾—æ¥ åœæ­¢ä½ï¼šç”¨äºæ•°æ®å¸§é—´éš”ï¼Œå›ºå®šä¸ºé«˜ç”µå¹³ USARTç®€ä»‹ USARTï¼ˆUniversal Synchronous/Asynchronous Receiver/Transmitterï¼‰é€šç”¨åŒæ­¥/å¼‚æ­¥æ”¶å‘å™¨ USARTæ˜¯STM32å†…éƒ¨é›†æˆçš„ç¡¬ä»¶å¤–è®¾ï¼Œå¯æ ¹æ®æ•°æ®å¯„å­˜å™¨çš„ä¸€ä¸ªå­—èŠ‚æ•°æ®è‡ªåŠ¨ç”Ÿæˆæ•°æ®å¸§æ—¶åºï¼Œä»TXå¼•è„šå‘é€å‡ºå»ï¼Œä¹Ÿå¯è‡ªåŠ¨æ¥æ”¶RXå¼•è„šçš„æ•°æ®å¸§æ—¶åºï¼Œæ‹¼æ¥ä¸ºä¸€ä¸ªå­—èŠ‚æ•°æ®ï¼Œå­˜æ”¾åœ¨æ•°æ®å¯„å­˜å™¨é‡Œ è‡ªå¸¦æ³¢ç‰¹ç‡å‘ç”Ÿå™¨ï¼Œæœ€é«˜è¾¾4.5Mbits/s å¯é…ç½®æ•°æ®ä½é•¿åº¦ï¼ˆ8/9ï¼‰ã€åœæ­¢ä½é•¿åº¦ï¼ˆ0.5/1/1.5/2ï¼‰ å¯é€‰æ ¡éªŒä½ï¼ˆæ— æ ¡éªŒ/å¥‡æ ¡éªŒ/å¶æ ¡éªŒï¼‰ æ”¯æŒåŒæ­¥æ¨¡å¼ã€ç¡¬ä»¶æµæ§åˆ¶ã€DMAã€æ™ºèƒ½å¡ã€IrDAã€LIN å®é™…å¤–è®¾: STM32F103C8T6 USARTèµ„æºï¼šUSART1ã€USART2ã€USART3\næ›´å¤šUSARTçš„ç›¸å…³å†…å®¹ï¼šSTM32F10xxxå‚è€ƒæ‰‹å†Œï¼ˆä¸­æ–‡ï¼‰.pdf é¡µç 516/æ‰‹å†Œ25\nä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 //æ•°æ®æ¥æ”¶å…¨å±€å˜é‡ uint8_t Serial_RxData; uint8_t Serial_RxFlag; //æ—¶é’Ÿé…ç½® RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //GPIOé…ç½® GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); //TX GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); //RX //USARTé…ç½® USART_InitTypeDef USART_InitStructure; USART_InitStructure.USART_BaudRate = 9600; USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx; USART_InitStructure.USART_Parity = USART_Parity_No; USART_InitStructure.USART_StopBits = USART_StopBits_1; USART_InitStructure.USART_WordLength = USART_WordLength_8b; USART_Init(USART1, \u0026amp;USART_InitStructure); //ä¸­æ–­é…ç½® USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); NVIC_InitTypeDef NVIC_InitStructure; NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1; NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; NVIC_Init(\u0026amp;NVIC_InitStructure); //USARTä½¿èƒ½ USART_Cmd(USART1, ENABLE); //å‘é€å­—èŠ‚ void Serial_SendByte(uint8_t Byte) { USART_SendData(USART1, Byte); while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET); } //è¿”å›æ¥æ”¶æ•°æ® uint8_t Serial_GetRxData(void) { return Serial_RxData; } void USART1_IRQHandler(void) { if (USART_GetITStatus(USART1, USART_IT_RXNE) == SET) { Serial_RxData = USART_ReceiveData(USART1); Serial_RxFlag = 1; USART_ClearITPendingBit(USART1, USART_IT_RXNE); } } USART_InitTypeDefä¸ºUSARTé…ç½®ç»“æ„ä½“ USART_BaudRateä¸ºæ³¢ç‰¹ç‡ï¼šå¸¸ç”¨9600ã€115200ç­‰ USART_HardwareFlowControlä¸ºç¡¬ä»¶æµæ§åˆ¶ï¼ˆä¸€èˆ¬ä¸ç”¨ï¼‰ USART_Modeä¸ºæ¨¡å¼ USART_Parityä¸ºå¥‡å¶æ ¡éªŒ USART_StopBitsä¸ºåœæ­¢ä½ USART_WordLengthä¸ºå­—é•¿ USART_ITConfigå‡½æ•°ç”¨äºé…ç½®USARTä¸­æ–­ USART_SendDataå‡½æ•°ç”¨äºå‘é€æ•°æ® USART_ReceiveDataå‡½æ•°ç”¨äºè¯»å–æ¥æ”¶åˆ°çš„æ•°æ® è·å–USARTæ ‡å¿—ä½ USART_GetFlagStatusæ ‡å¿—ä½ USART_GetITStatusä¸­æ–­æ ‡å¿—ä½ USART_HardwareFlowControl å€¼ æè¿° USART_HardwareFlowControl_None ((uint16_t)0x0000) å…³é—­ USART_HardwareFlowControl_RTS ((uint16_t)0x0100) å‘é€å¯æ¥æ”¶ä¿¡å· USART_HardwareFlowControl_CTS ((uint16_t)0x0200) æ¥æ”¶å¯å‘é€ä¿¡å· USART_HardwareFlowControl_RTS_CTS ((uint16_t)0x0300) å¼€å¯å…¨éƒ¨ USART_Mode å€¼ æè¿° USART_Mode_Rx ((uint16_t)0x0004) å‘é€ USART_Mode_Tx ((uint16_t)0x0008) æ¥æ”¶ USART_Parity å€¼ æè¿° USART_Parity_No ((uint16_t)0x0000) ä¸æ ¡éªŒ USART_Parity_Even ((uint16_t)0x0400) å¶æ ¡éªŒ USART_Parity_Odd ((uint16_t)0x0600) å¥‡æ ¡éªŒ USART_StopBits å€¼ æè¿° USART_StopBits_1 ((uint16_t)0x0000) 1ä½åœæ­¢ä½ USART_StopBits_0_5 ((uint16_t)0x1000) 0.5ä½åœæ­¢ä½ USART_StopBits_2 ((uint16_t)0x2000) 2ä½åœæ­¢ä½ USART_StopBits_1_5 ((uint16_t)0x3000) 1.5ä½åœæ­¢ä½ USART_WordLength å€¼ æè¿° USART_WordLength_8b ((uint16_t)0x0000) 8ä½æ•°æ® USART_WordLength_9b ((uint16_t)0x1000) 9ä½æ•°æ® USART_ITs å€¼ USART_Flags å€¼ æè¿° USART_IT_PE ((uint16_t)0x0028) USART_FLAG_PE ((uint16_t)0x0001) å¥‡å¶æ£€éªŒé”™ USART_IT_TXE ((uint16_t)0x0727) USART_FLAG_TXE ((uint16_t)0x0080) å‘é€æ•°æ®å¯„å­˜å™¨ç©º USART_IT_TC ((uint16_t)0x0626) USART_FLAG_TC ((uint16_t)0x0040) å‘é€å®Œæˆ USART_IT_RXNE ((uint16_t)0x0525) USART_FLAG_RXNE ((uint16_t)0x0020) æ¥æ”¶æ•°æ®å°±ç»ªå¯è¯» USART_IT_IDLE ((uint16_t)0x0424) USART_FLAG_IDLE ((uint16_t)0x0010) æ£€æµ‹åˆ°ç©ºé—²çº¿è·¯ USART_IT_LBD ((uint16_t)0x0846) USART_FLAG_LBD ((uint16_t)0x0100) æ–­å¼€æ ‡å¿— USART_IT_CTS ((uint16_t)0x096A) USART_FLAG_CTS ((uint16_t)0x0200) CTSæ ‡å¿— USART_IT_ERR ((uint16_t)0x0060) æœªå¼€å¯USART_IT_ERRæ—¶ï¼Œåªèƒ½ç”±USART_GetFlagStatus(USARTx,USART_Flag_ORE)Â æ£€æµ‹åˆ°USART_IT_OREï¼›åœ¨å¼€å¯USART_IT_ERRåï¼Œæ‰èƒ½è¢«Â USART_GetITStatus(USARTx,USART_IT_ORE)Â æ£€æµ‹åˆ°USART_IT_OREï¼› USART_IT_ORE ((uint16_t)0x0360) USART_FLAG_ORE ((uint16_t)0x0008) æ£€æµ‹åˆ°æ•°æ®æº¢å‡º USART_IT_NE ((uint16_t)0x0260) USART_FLAG_NE ((uint16_t)0x0004) å™ªå£°æ ‡å¿— USART_IT_FE ((uint16_t)0x0160) USART_FLAG_FE ((uint16_t)0x0002) å¸§é”™è¯¯ æ•°æ®åŒ…è®¾è®¡ HEXå›ºå®šåŒ…é•¿ å­—ç¬¦å¯å˜åŒ…é•¿ ","date":"2024-02-17T00:00:00Z","permalink":"https://detail47.github.io/p/stm32-usart/","title":"STM32 USART"},{"content":"ADCç®€ä»‹ ADCï¼ˆAnalog-Digital Converterï¼‰æ¨¡æ‹Ÿ-æ•°å­—è½¬æ¢å™¨ ADCå¯ä»¥å°†å¼•è„šä¸Šè¿ç»­å˜åŒ–çš„æ¨¡æ‹Ÿç”µå‹è½¬æ¢ä¸ºå†…å­˜ä¸­å­˜å‚¨çš„æ•°å­—å˜é‡ï¼Œå»ºç«‹æ¨¡æ‹Ÿç”µè·¯åˆ°æ•°å­—ç”µè·¯çš„æ¡¥æ¢ 12ä½é€æ¬¡é€¼è¿‘å‹ADCï¼Œ1usè½¬æ¢æ—¶é—´ è¾“å…¥ç”µå‹èŒƒå›´ï¼š0-3.3Vï¼Œè½¬æ¢ç»“æœèŒƒå›´ï¼š0-4095 18ä¸ªè¾“å…¥é€šé“ï¼Œå¯æµ‹é‡16ä¸ªå¤–éƒ¨å’Œ2ä¸ªå†…éƒ¨ä¿¡å·æº è§„åˆ™ç»„å’Œæ³¨å…¥ç»„ä¸¤ä¸ªè½¬æ¢å•å…ƒ æ¨¡æ‹Ÿçœ‹é—¨ç‹—è‡ªåŠ¨ç›‘æµ‹è¾“å…¥ç”µå‹èŒƒå›´ STM32F103C8T6 ADCèµ„æºï¼šADC1ã€ADC2ï¼Œ10ä¸ªå¤–éƒ¨è¾“å…¥é€šé“ é€šé“ ADC1 ADC2 ADC3 é€šé“0 PA0 PA0 PA0 é€šé“1 PA1 PA1 PA1 é€šé“2 PA2 PA2 PA2 é€šé“3 PA3 PA3 PA3 é€šé“4 PA4 PA4 PF6 é€šé“5 PA5 PA5 PF7 é€šé“6 PA6 PA6 PF8 é€šé“7 PA7 PA7 PF9 é€šé“8 PB0 PB0 PF10 é€šé“9 PB1 PB1 é€šé“10 PC0 PC0 PC0 é€šé“11 PC1 PC1 PC1 é€šé“12 PC2 PC2 PC2 é€šé“13 PC3 PC3 PC3 é€šé“14 PC4 PC4 é€šé“15 PC5 PC5 é€šé“16 æ¸©åº¦ä¼ æ„Ÿå™¨ é€šé“17 å†…éƒ¨å‚è€ƒç”µå‹ è½¬æ¢æ¨¡å¼ å•æ¬¡è½¬æ¢ï¼Œéæ‰«ææ¨¡å¼ å•æ¬¡è½¬æ¢ï¼Œéæ‰«ææ¨¡å¼ è¿ç»­è½¬æ¢ï¼Œéæ‰«ææ¨¡å¼ è¿ç»­è½¬æ¢ï¼Œéæ‰«ææ¨¡å¼ æ•°æ®å¯¹é½ è§¦å‘æ§åˆ¶ ADè½¬æ¢çš„æ­¥éª¤ï¼šé‡‡æ ·ï¼Œä¿æŒï¼Œé‡åŒ–ï¼Œç¼–ç  STM32 ADCçš„æ€»è½¬æ¢æ—¶é—´ä¸ºï¼š $$ T_{CONV} = T_{sampling} + 12.5T_{ADC} $$ ä¾‹å¦‚ï¼šå½“ADCCLK=14MHzï¼Œé‡‡æ ·æ—¶é—´ä¸º1.5ä¸ªADCå‘¨æœŸ $$ T_{CONV} = (1.5 + 12.5)T_{ADC} = 14T_{ADC} = 1Î¼s $$ ä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 //é…ç½®æ—¶é’Ÿ RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); RCC_ADCCLKConfig(RCC_PCLK2_Div6); //GPIOé…ç½® GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); //ADCé…ç½® ADC_InitTypeDef ADC_InitStructure; ADC_InitStructure.ADC_Mode = ADC_Mode_Independent; ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; ADC_InitStructure.ADC_ContinuousConvMode = DISABLE; ADC_InitStructure.ADC_ScanConvMode = DISABLE; ADC_InitStructure.ADC_NbrOfChannel = 1; ADC_Init(ADC1, \u0026amp;ADC_InitStructure); //ADCä½¿èƒ½ ADC_Cmd(ADC1, ENABLE); //ADCæ ¡å‡† ADC_ResetCalibration(ADC1); while (ADC_GetResetCalibrationStatus(ADC1) == SET); ADC_StartCalibration(ADC1); while (ADC_GetCalibrationStatus(ADC1) == SET); //è·å–å€¼ uint16_t AD_GetValue(uint8_t ADC_Channel) { ADC_RegularChannelConfig(ADC1, ADC_Channel, 1, ADC_SampleTime_55Cycles5); ADC_SoftwareStartConvCmd(ADC1, ENABLE); while (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET); return ADC_GetConversionValue(ADC1); } RCC_ADCCLKConfigå‡½æ•°ç”¨äºé…ç½®ADCæ—¶é’Ÿåˆ†é¢‘ï¼ˆADCæœ€é«˜æ”¯æŒ14Mæ—¶é’Ÿï¼‰ GPIO_InitTypeDefä¸ºADCé…ç½®ç»“æ„ä½“ ADC_Modeä¸ºADCæ¨¡å¼ ADC_DataAlignä¸ºæ•°æ®å¯¹é½æ¨¡å¼ ADC_ExternalTrigConvä¸ºå¤–éƒ¨è§¦å‘æ¨¡å¼ ADC_ContinuousConvModeä¸ºè¿ç»­è½¬æ¢ä½¿èƒ½ ADC_ScanConvModeä¸ºæ‰«ææ¨¡å¼ä½¿èƒ½ ADC_NbrOfChannelä¸ºADCé€šé“æ•° ADC_ResetCalibrationå‡½æ•°ç”¨äºå¤ä½ADCæ ¡å‡†å¯„å­˜å™¨ ADC_GetResetCalibrationStatuså‡½æ•°ç”¨äºæ£€æŸ¥ADCæ ¡å‡†å¯„å­˜å™¨çŠ¶æ€ ADC_StartCalibrationå‡½æ•°ç”¨äºæ ¡å‡†ADC ADC_GetCalibrationStatuså‡½æ•°ç”¨äºæ£€æŸ¥ADCæ ¡å‡† ADC_RegularChannelConfigå‡½æ•°ç”¨äºé…ç½®è§„åˆ™ç»„é€šé“ ADC_Channelä¸ºADCé€šé“ï¼šADC_Channel_x ADC_SampleTimeä¸ºé‡‡æ ·æ—¶é—´ ADC_GetFlagStatuså‡½æ•°ç”¨äºè·å–ADCæ ‡å¿—ä½ ADC_GetConversionValueå‡½æ•°ç”¨äºè·å–è§„åˆ™ç»„ç»“æœ ADC_SoftwareStartConvCmdå‡½æ•°ç”¨äºè½¯ä»¶è§¦å‘ADC RCC_PCLK2 å€¼ æè¿° RCC_PCLK2_Div2 ((uint32_t)0x00000000) äºŒåˆ†é¢‘ RCC_PCLK2_Div4 ((uint32_t)0x00004000) å››åˆ†é¢‘ RCC_PCLK2_Div6 ((uint32_t)0x00008000) å…­åˆ†é¢‘ RCC_PCLK2_Div8 ((uint32_t)0x0000C000) å…«åˆ†é¢‘ ADC_Mode å€¼ æè¿° ADC_Mode_Independent ((uint32_t)0x00000000) ç‹¬ç«‹æ¨¡å¼ ADC_Mode_RegInjecSimult ((uint32_t)0x00010000) æ··åˆçš„åŒæ­¥è§„åˆ™+æ³¨å…¥åŒæ­¥æ¨¡å¼ ADC_Mode_RegSimult_AlterTrig ((uint32_t)0x00020000) æ··åˆçš„åŒæ­¥è§„åˆ™+äº¤æ›¿è§¦å‘æ¨¡å¼ ADC_Mode_InjecSimult_FastInterl ((uint32_t)0x00030000) æ··åˆåŒæ­¥æ³¨å…¥+å¿«é€Ÿäº¤å‰æ¨¡å¼ ADC_Mode_InjecSimult_SlowInterl ((uint32_t)0x00040000) æ··åˆåŒæ­¥æ³¨å…¥+æ…¢é€Ÿäº¤å‰æ¨¡å¼ ADC_Mode_InjecSimult ((uint32_t)0x00050000) æ³¨å…¥åŒæ­¥æ¨¡å¼ ADC_Mode_RegSimult ((uint32_t)0x00060000) è§„åˆ™åŒæ­¥æ¨¡å¼ ADC_Mode_FastInterl ((uint32_t)0x00070000) å¿«é€Ÿäº¤å‰æ¨¡å¼ ADC_Mode_SlowInterl ((uint32_t)0x00080000) æ…¢é€Ÿäº¤å‰æ¨¡å¼ ADC_Mode_AlterTrig ((uint32_t)0x00090000) äº¤æ›¿è§¦å‘æ¨¡å¼ æ›´å¤šADC_Modeçš„ç›¸å…³å†…å®¹ï¼šSTM32F10xxxå‚è€ƒæ‰‹å†Œï¼ˆä¸­æ–‡ï¼‰.pdf é¡µç 163/æ‰‹å†Œ11.9\nADC_DataAlign å€¼ æè¿° ADC_DataAlign_Right ((uint32_t)0x00000000) å³å¯¹é½ ADC_DataAlign_Left ((uint32_t)0x00000800) å·¦å¯¹é½ ADC_ExternalTrigConv å€¼ æè¿° ADC_ExternalTrigConv_T1_CC1 ((uint32_t)0x00000000) å†…éƒ¨ä¿¡å· ADC_ExternalTrigConv_T1_CC2 ((uint32_t)0x00020000) å†…éƒ¨ä¿¡å· ADC_ExternalTrigConv_T2_CC2 ((uint32_t)0x00060000) å†…éƒ¨ä¿¡å· ADC_ExternalTrigConv_T3_TRGO ((uint32_t)0x00080000) å†…éƒ¨ä¿¡å· ADC_ExternalTrigConv_T4_CC4 ((uint32_t)0x000A0000) å†…éƒ¨ä¿¡å· ADC_ExternalTrigConv_Ext_IT11_TIM8_TRGO ((uint32_t)0x000C0000) å¤–éƒ¨å¼•è„š/å†…éƒ¨ä¿¡å· ADC_ExternalTrigConv_T1_CC3 ((uint32_t)0x00040000) å†…éƒ¨ä¿¡å· ADC_ExternalTrigConv_None ((uint32_t)0x000E0000) è½¯ä»¶è§¦å‘ ADC_ExternalTrigConv_T3_CC1 ((uint32_t)0x00000000) å†…éƒ¨ä¿¡å· ADC_ExternalTrigConv_T2_CC3 ((uint32_t)0x00020000) å†…éƒ¨ä¿¡å· ADC_ExternalTrigConv_T8_CC1 ((uint32_t)0x00060000) å†…éƒ¨ä¿¡å· ADC_ExternalTrigConv_T8_TRGO ((uint32_t)0x00080000) å†…éƒ¨ä¿¡å· ADC_ExternalTrigConv_T5_CC1 ((uint32_t)0x000A0000) å†…éƒ¨ä¿¡å· ADC_ExternalTrigConv_T5_CC3 ((uint32_t)0x000C0000) å†…éƒ¨ä¿¡å· å‰å…­ä¸ªä¸åå…­ä¸ªåˆ†åˆ«å¯¹åº”ADC12å’ŒADC3ï¼Œç¬¬ä¸ƒã€å…«ä¸ªå¯ç”¨äºADC123 æ›´å¤šå¤–éƒ¨è§¦å‘ç›¸å…³å†…å®¹ï¼šSTM32F10xxxå‚è€ƒæ‰‹å†Œï¼ˆä¸­æ–‡ï¼‰.pdf é¡µç 162/æ‰‹å†Œ11.7\nADC_SampleTime å€¼ æè¿° ADC_SampleTime_1Cycles5 ((uint8_t)0x00) Sample time equal to 1.5 cycles ADC_SampleTime_7Cycles5 ((uint8_t)0x01) Sample time equal to 7.5 cycles ADC_SampleTime_13Cycles5 ((uint8_t)0x02) Sample time equal to 13.5 cycles ADC_SampleTime_28Cycles5 ((uint8_t)0x03) Sample time equal to 28.5 cycles ADC_SampleTime_41Cycles5 ((uint8_t)0x04) Sample time equal to 41.5 cycles ADC_SampleTime_55Cycles5 ((uint8_t)0x05) Sample time equal to 55.5 cycles ADC_SampleTime_71Cycles5 ((uint8_t)0x06) Sample time equal to 71.5 cycles ADC_SampleTime_239Cycles5 ((uint8_t)0x07) Sample time equal to 239.5 cycles ","date":"2024-02-16T00:00:00Z","permalink":"https://detail47.github.io/p/stm32-adc/","title":"STM32 ADC"},{"content":"TIMç®€ä»‹ TIMï¼ˆTimerï¼‰å®šæ—¶å™¨ å®šæ—¶å™¨å¯ä»¥å¯¹è¾“å…¥çš„æ—¶é’Ÿè¿›è¡Œè®¡æ•°ï¼Œå¹¶åœ¨è®¡æ•°å€¼è¾¾åˆ°è®¾å®šå€¼æ—¶è§¦å‘ä¸­æ–­ 16ä½è®¡æ•°å™¨ã€é¢„åˆ†é¢‘å™¨ã€è‡ªåŠ¨é‡è£…å¯„å­˜å™¨çš„æ—¶åŸºå•å…ƒï¼Œåœ¨72MHzè®¡æ•°æ—¶é’Ÿä¸‹å¯ä»¥å®ç°æœ€å¤§59.65sçš„å®šæ—¶ ä¸ä»…å…·å¤‡åŸºæœ¬çš„å®šæ—¶ä¸­æ–­åŠŸèƒ½ï¼Œè€Œä¸”è¿˜åŒ…å«å†…å¤–æ—¶é’Ÿæºé€‰æ‹©ã€è¾“å…¥æ•è·ã€è¾“å‡ºæ¯”è¾ƒã€ç¼–ç å™¨æ¥å£ã€ä¸»ä»è§¦å‘æ¨¡å¼ç­‰å¤šç§åŠŸèƒ½ æ ¹æ®å¤æ‚åº¦å’Œåº”ç”¨åœºæ™¯åˆ†ä¸ºäº†é«˜çº§å®šæ—¶å™¨ã€é€šç”¨å®šæ—¶å™¨ã€åŸºæœ¬å®šæ—¶å™¨ä¸‰ç§ç±»å‹ å®é™…å¤–è®¾: STM32F103C8T6å®šæ—¶å™¨èµ„æºï¼šTIM1ã€TIM2ã€TIM3ã€TIM4\nç±»å‹ ç¼–å· æ€»çº¿ åŠŸèƒ½ é«˜çº§å®šæ—¶å™¨ TIM1ã€TIM8 APB2 æ‹¥æœ‰é€šç”¨å®šæ—¶å™¨å…¨éƒ¨åŠŸèƒ½ï¼Œå¹¶é¢å¤–å…·æœ‰é‡å¤è®¡æ•°å™¨ã€æ­»åŒºç”Ÿæˆã€äº’è¡¥è¾“å‡ºã€åˆ¹è½¦è¾“å…¥ç­‰åŠŸèƒ½ é€šç”¨å®šæ—¶å™¨ TIM2ã€TIM3ã€TIM4ã€TIM5 APB1 æ‹¥æœ‰åŸºæœ¬å®šæ—¶å™¨å…¨éƒ¨åŠŸèƒ½ï¼Œå¹¶é¢å¤–å…·æœ‰å†…å¤–æ—¶é’Ÿæºé€‰æ‹©ã€è¾“å…¥æ•è·ã€è¾“å‡ºæ¯”è¾ƒã€ç¼–ç å™¨æ¥å£ã€ä¸»ä»è§¦å‘æ¨¡å¼ç­‰åŠŸèƒ½ åŸºæœ¬å®šæ—¶å™¨ TIM6ã€TIM7 APB1 æ‹¥æœ‰å®šæ—¶ä¸­æ–­ã€ä¸»æ¨¡å¼è§¦å‘DACçš„åŠŸèƒ½ TIMç»“æ„ ä¸»è¦ç»“æ„ é¢„åˆ†é¢‘å™¨ PSC è®¡æ•°å™¨ CNT è‡ªåŠ¨é‡è£…å™¨ ARR é‡å¤è®¡æ•°å™¨ REP é«˜çº§å®šæ—¶å™¨ é€šç”¨å®šæ—¶å™¨ åŸºæœ¬å®šæ—¶å™¨ å®šæ—¶å™¨ä¸­æ–­ç»“æ„ å®šæ—¶å™¨çš„è§¦å‘æ¨¡å¼ å†…éƒ¨æ—¶é’Ÿè§¦å‘ï¼šCK_INT å¤–éƒ¨æ—¶é’Ÿè§¦å‘ï¼ˆå¤–éƒ¨æ—¶é’Ÿæ¨¡å¼2ï¼‰ï¼šETR ä»æ¨¡å¼è§¦å‘ï¼ˆå¤–éƒ¨æ—¶é’Ÿæ¨¡å¼1ï¼‰ï¼šTRGI ç¼–ç å™¨æ¥å£è§¦å‘ï¼šTI1FP1\u0026amp;TI2FP2 æ—¶åŸºå•å…ƒ é¢„åˆ†é¢‘å™¨ è®¡æ•°å™¨è®¡æ•°é¢‘ç‡ï¼š\n$$ CK_{CNT}=\\frac{CK_{PSC}}{PSC+1} $$è®¡æ•°å™¨ è®¡æ•°å™¨æº¢å‡ºé¢‘ç‡ï¼š\n$$ CK_{CNT_{OV}}=\\frac{CK_{CNT}}{ARR+1} $$$$ CK_{CNT_{OV}}=\\frac{CK_{PSC}}{(PSC+1)(ARR+1)} $$ARPE=0æ—¶ï¼ŒTIMx_ARRæ— é¢„è£…å…¥ã€‚ARRå€¼å³åˆ»ç”Ÿæ•ˆï¼ˆä¸å»ºè®®ï¼‰ ARPE=1æ—¶ï¼ŒTIMx_ARRæœ‰é¢„è£…å…¥ã€‚ARRå€¼åœ¨ä¸‹æ¬¡é‡è£…æ—¶ç”Ÿæ•ˆ\nä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 //å¼€å¯æ—¶é’Ÿ RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE); //é…ç½®TIM2ä¸ºå†…éƒ¨æ—¶é’Ÿ TIM_InternalClockConfig(TIM2); //æ—¶åŸºå•å…ƒåˆå§‹åŒ– TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure; TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1; TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; TIM_TimeBaseInitStructure.TIM_Period = 10000 - 1; TIM_TimeBaseInitStructure.TIM_Prescaler = 7200 - 1; TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0; TIM_TimeBaseInit(TIM2, \u0026amp;TIM_TimeBaseInitStructure); //ä¸­æ–­é…ç½® TIM_ClearFlag(TIM2, TIM_FLAG_Update); TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE); //NVICé…ç½® NVIC_InitTypeDef NVIC_InitStructure; NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn; NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2; NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; NVIC_Init(\u0026amp;NVIC_InitStructure); //ä½¿èƒ½å®šæ—¶å™¨ TIM_Cmd(TIM2, ENABLE); //ä¸­æ–­å‡½æ•° void TIM2_IRQHandler(void) { if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET) { TIM_ClearITPendingBit(TIM2, TIM_IT_Update); } } é…ç½®TIMæ—¶é’Ÿ é€‰æ‹©å†…éƒ¨æ—¶é’Ÿ( INT )ï¼švoid TIM_InternalClockConfig(TIM_TypeDef* TIMx); é€‰æ‹©å…¶ä»–å®šæ—¶å™¨( ITRx )ï¼švoid TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource); é€‰æ‹©å¤–éƒ¨å¼•è„š( TIx )ï¼švoid TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource, uint16_t TIM_ICPolarity, uint16_t ICFilter); é€‰æ‹©å¤–éƒ¨æ—¶é’Ÿ( ETR ) æ¨¡å¼1( TRGI )ï¼švoid TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter); æ¨¡å¼2ï¼švoid TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter); ä¸»è¦å‚æ•°ï¼š\nTIMxä¸ºTIMç¼–å· TIM_InputTriggerSourceä¸ºè¾“å…¥å®šæ—¶å™¨æº TIM_TIxExternalCLKSourceä¸ºå¤–éƒ¨è¾“å…¥å¼•è„š TIM_ICPolarityä¸ºå¤–éƒ¨å¼•è„šææ€§é€‰æ‹© ICFilterä¸ºå¤–éƒ¨å¼•è„šæ»¤æ³¢å™¨ï¼š0x0-0xF TIM_ExtTRGPrescalerä¸ºå¤–éƒ¨æ—¶é’Ÿé¢„åˆ†é¢‘å™¨ TIM_ExtTRGPolarityä¸ºå¤–éƒ¨æ—¶é’Ÿææ€§ ExtTRGFilterä¸ºå¤–éƒ¨æ—¶é’Ÿæ»¤æ³¢å™¨ï¼š0x0-0xF TIM_InputTriggerSource å€¼ æè¿° TIM_TS_ITR0 ((uint16_t)0x0000) TIMå†…éƒ¨è§¦å‘0 TIM_TS_ITR1 ((uint16_t)0x0010) TIMå†…éƒ¨è§¦å‘1 TIM_TS_ITR2 ((uint16_t)0x0020) TIMå†…éƒ¨è§¦å‘2 TIM_TS_ITR3 ((uint16_t)0x0030) TIMå†…éƒ¨è§¦å‘3 TIM_TIxExternalCLKSource å€¼ æè¿° TIM_TS_TI1FP1 ((uint16_t)0x0050) TIMIC1è¿æ¥TI1ï¼ˆå³ä½¿ç”¨TIMx_CH1ï¼‰ TIM_TS_TI2FP2 ((uint16_t)0x0060) TIMIC2è¿æ¥TI2ï¼ˆå³ä½¿ç”¨TIMx_CH2ï¼‰ TIM_TS_TI1F_ED ((uint16_t)0x0040) TIMIC1è¿æ¥TI1ï¼Œä½¿ç”¨è¾¹ç¼˜æ£€æµ‹ TIM_ExtTRGPrescaler å€¼ æè¿° TIM_ExtTRGPSC_OFF ((uint16_t)0x0000) TIM ETRP ä¸åˆ†é¢‘ TIM_ExtTRGPSC_DIV2 ((uint16_t)0x1000) TIM ETRP äºŒåˆ†é¢‘ TIM_ExtTRGPSC_DIV4 ((uint16_t)0x2000) TIM ETRP å››åˆ†é¢‘ TIM_ExtTRGPSC_DIV8 ((uint16_t)0x3000) TIM ETRP å…«åˆ†é¢‘ TIM_ICPolarity å€¼ æè¿° TIM_ICPolarity_Rising ((uint16_t)0x0000) ä¸Šå‡æ²¿æœ‰æ•ˆ TIM_ICPolarity_Falling ((uint16_t)0x0002) ä¸‹é™æ²¿æœ‰æ•ˆ TIM_ICPolarity_BothEdge ((uint16_t)0x000A) åŒè¾¹ç¼˜æœ‰æ•ˆ TIM_ICPolarity å€¼ æè¿° TIM_ExtTRGPolarity_Inverted ((uint16_t)0x8000) ææ€§ç¿»è½¬ï¼Œä½ç”µå¹³æˆ–ä¸‹é™æ²¿æœ‰æ•ˆ TIM_ExtTRGPolarity_NonInverted ((uint16_t)0x0000) ææ€§ä¸ç¿»è½¬ï¼Œé«˜ç”µå¹³æˆ–ä¸Šå‡æ²¿æœ‰æ•ˆ é…ç½®æ—¶åŸºå•å…ƒ TIM_ClockDivisionä¸ºæ—¶é’Ÿåˆ†é¢‘ï¼Œä¸é¢„åˆ†é¢‘å™¨ä½œç”¨ç±»ä¼¼ï¼Œä½†ä½œç”¨æœ‰é™ TIM_CounterModeä¸ºè®¡æ•°æ–¹å¼ TIM_Periodä¸ºè‡ªåŠ¨é‡è£…å€¼( ARR ) TIM_Prescalerä¸ºé¢„åˆ†é¢‘ç³»æ•°( PSC ) TIM_RepetitionCounterä¸ºé‡å¤è®¡æ•°å€¼( REP ï¼Œä»…é«˜çº§å®šæ—¶å™¨æœ‰æ•ˆ) TIM_ClockDivision å€¼ æè¿° TIM_CKD_DIV1 ((uint16_t)0x0000) ä¸åˆ†é¢‘ TIM_CKD_DIV2 ((uint16_t)0x0100) äºŒåˆ†é¢‘ TIM_CKD_DIV4 ((uint16_t)0x0200) å››åˆ†é¢‘ TIM_CounterMode å€¼ æè¿° TIM_CounterMode_Up ((uint16_t)0x0000) å‘ä¸Šè®¡æ•°æ¨¡å¼ TIM_CounterMode_Down ((uint16_t)0x0010) å‘ä¸‹è®¡æ•°æ¨¡å¼ TIM_CounterMode_CenterAligned1 ((uint16_t)0x0020) ä¸­å¿ƒå¯¹é½è®¡æ•°æ¨¡å¼ï¼Œå‘ä¸‹è®¡æ•°æ—¶åŒ¹é… TIM_CounterMode_CenterAligned2 ((uint16_t)0x0040) ä¸­å¿ƒå¯¹é½è®¡æ•°æ¨¡å¼ï¼Œå‘ä¸Šè®¡æ•°æ—¶åŒ¹é… TIM_CounterMode_CenterAligned3 ((uint16_t)0x0060) ä¸­å¿ƒå¯¹é½è®¡æ•°æ¨¡å¼ï¼ŒåŒ¹é…æ‰€æœ‰ é…ç½®ä¸­æ–­ åœ¨åˆå§‹åŒ–æ—¶åŸºå•å…ƒåï¼Œä¼šäº§ç”Ÿä¸€ä¸ªæ›´æ–°äº‹ä»¶æ¥è£…å…¥è‡ªåŠ¨é‡è£…å€¼ã€‚å› æ­¤éœ€è¦ç”¨ TIM_ClearFlagæ¸…é™¤ä¸­æ–­æ ‡å¿—ä½ï¼ˆå½“ä½¿ç”¨æ›´æ–°ä¸­æ–­æ—¶ï¼‰ å®šæ—¶å™¨èƒ½äº§ç”Ÿå¤šç§ä¸­æ–­ï¼Œéœ€è¦ç”¨ TIM_ITConfigé…ç½® TIM_IT å€¼ æè¿° TIM_IT_Update ((uint16_t)0x0001) æ›´æ–°ä¸­æ–­ï¼Œè®¡æ•°å™¨å‘ä¸Šæº¢å‡º/å‘ä¸‹æº¢å‡ºï¼Œè®¡æ•°å™¨åˆå§‹åŒ– TIM_IT_CC1 ((uint16_t)0x0002) æ•è·/æ¯”è¾ƒä¸­æ–­ï¼ŒCH1 TIM_IT_CC2 ((uint16_t)0x0004) æ•è·/æ¯”è¾ƒä¸­æ–­ï¼ŒCH2 TIM_IT_CC3 ((uint16_t)0x0008) æ•è·/æ¯”è¾ƒä¸­æ–­ï¼ŒCH3 TIM_IT_CC4 ((uint16_t)0x0010) æ•è·/æ¯”è¾ƒä¸­æ–­ï¼ŒCH4 TIM_IT_Trigger ((uint16_t)0x0040) è§¦å‘äº‹ä»¶(è®¡æ•°å™¨å¯åŠ¨ã€åœæ­¢ã€åˆå§‹åŒ–æˆ–è€…ç”±å†…éƒ¨/å¤–éƒ¨è§¦å‘è®¡æ•°) è¾“å‡ºæ¯”è¾ƒ OCï¼ˆOutput Compareï¼‰è¾“å‡ºæ¯”è¾ƒ è¾“å‡ºæ¯”è¾ƒå¯ä»¥é€šè¿‡æ¯”è¾ƒCNTä¸CCRå¯„å­˜å™¨å€¼çš„å…³ç³»ï¼Œæ¥å¯¹è¾“å‡ºç”µå¹³è¿›è¡Œç½®1ã€ç½®0æˆ–ç¿»è½¬çš„æ“ä½œï¼Œç”¨äºè¾“å‡ºä¸€å®šé¢‘ç‡å’Œå ç©ºæ¯”çš„PWMæ³¢å½¢ æ¯ä¸ªé«˜çº§å®šæ—¶å™¨å’Œé€šç”¨å®šæ—¶å™¨éƒ½æ‹¥æœ‰4ä¸ªè¾“å‡ºæ¯”è¾ƒé€šé“ é«˜çº§å®šæ—¶å™¨çš„å‰3ä¸ªé€šé“é¢å¤–æ‹¥æœ‰æ­»åŒºç”Ÿæˆå’Œäº’è¡¥è¾“å‡ºçš„åŠŸèƒ½ æ¨¡å¼ æè¿° å†»ç»“ CNT=CCRæ—¶ï¼ŒREFä¿æŒä¸ºåŸçŠ¶æ€ åŒ¹é…æ—¶ç½®æœ‰æ•ˆç”µå¹³ CNT=CCRæ—¶ï¼ŒREFç½®æœ‰æ•ˆç”µå¹³ åŒ¹é…æ—¶ç½®æ— æ•ˆç”µå¹³ CNT=CCRæ—¶ï¼ŒREFç½®æ— æ•ˆç”µå¹³ åŒ¹é…æ—¶ç”µå¹³ç¿»è½¬ CNT=CCRæ—¶ï¼ŒREFç”µå¹³ç¿»è½¬ å¼ºåˆ¶ä¸ºæ— æ•ˆç”µå¹³ CNTä¸CCRæ— æ•ˆï¼ŒREFå¼ºåˆ¶ä¸ºæ— æ•ˆç”µå¹³ å¼ºåˆ¶ä¸ºæœ‰æ•ˆç”µå¹³ CNTä¸CCRæ— æ•ˆï¼ŒREFå¼ºåˆ¶ä¸ºæœ‰æ•ˆç”µå¹³ PWMæ¨¡å¼1 å‘ä¸Šè®¡æ•°ï¼šCNT\u0026lt;CCRæ—¶ï¼ŒREFç½®æœ‰æ•ˆç”µå¹³ï¼ŒCNTâ‰¥CCRæ—¶ï¼ŒREFç½®æ— æ•ˆç”µå¹³\u0026lt;br\u0026gt;å‘ä¸‹è®¡æ•°ï¼šCNT\u0026gt;CCRæ—¶ï¼ŒREFç½®æ— æ•ˆç”µå¹³ï¼ŒCNTâ‰¤CCRæ—¶ï¼ŒREFç½®æœ‰æ•ˆç”µå¹³ PWMæ¨¡å¼2 å‘ä¸Šè®¡æ•°ï¼šCNT\u0026lt;CCRæ—¶ï¼ŒREFç½®æ— æ•ˆç”µå¹³ï¼ŒCNTâ‰¥CCRæ—¶ï¼ŒREFç½®æœ‰æ•ˆç”µå¹³\u0026lt;br\u0026gt;å‘ä¸‹è®¡æ•°ï¼šCNT\u0026gt;CCRæ—¶ï¼ŒREFç½®æœ‰æ•ˆç”µå¹³ï¼ŒCNTâ‰¤CCRæ—¶ï¼ŒREFç½®æ— æ•ˆç”µå¹³ ä»¥PWMæ¨¡å¼1å‘ä¸Šè®¡æ•°ä¸ºä¾‹ï¼š PWMé¢‘ç‡ï¼š $$ Freq=\\frac{CK_{PSC}}{(PSC+1)(ARR+1)} $$ PWMå ç©ºæ¯”ï¼š $$ Duty=\\frac{CCR}{ARR+1} $$ PWMåˆ†è¾¨ç‡ï¼š $$ Reso=\\frac{1}{ARR+1} $$ä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 //å¼€å¯æ—¶é’Ÿ RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //GPIOåˆå§‹åŒ– GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); //æ—¶é’Ÿé…ç½® TIM_InternalClockConfig(TIM2); //æ—¶åŸºå•å…ƒåˆå§‹åŒ– TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure; TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1; TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; TIM_TimeBaseInitStructure.TIM_Period = 100 - 1; TIM_TimeBaseInitStructure.TIM_Prescaler = 720 - 1; TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0; TIM_TimeBaseInit(TIM2, \u0026amp;TIM_TimeBaseInitStructure); //è¾“å‡ºæ¯”è¾ƒåˆå§‹åŒ– TIM_OCInitTypeDef TIM_OCInitStructure; TIM_OCStructInit(\u0026amp;TIM_OCInitStructure); TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; TIM_OCInitStructure.TIM_Pulse = 0; TIM_OC1Init(TIM2, \u0026amp;TIM_OCInitStructure); //ä½¿èƒ½å®šæ—¶å™¨ TIM_Cmd(TIM2, ENABLE); //CCRè®¾ç½®å‡½æ•° void PWM_SetCompare1(uint16_t Compare) { TIM_SetCompare1(TIM2, Compare); } //ARRè®¾ç½®å‡½æ•° void PWM_SetAutoreload(uint16_t Autoreload) { TIM_SetAutoreload(TIM2, Autoreload); } //PSCè®¾ç½®å‡½æ•° void PWM_SetPrescaler(uint16_t Prescaler) { TIM_PrescalerConfig(TIM2, Prescaler, TIM_PSCReloadMode_Update); } TIM_OCInitTypeDefä¸ºè¾“å‡ºæ¯”è¾ƒé…ç½®ç»“æ„ä½“\nTIM_OCStructInitå‡½æ•°ä¸ºç»“æ„ä½“èµ‹é»˜è®¤å€¼ï¼ˆç‰¹åˆ«ï¼‰ TIM_SetComparexå‡½æ•°èƒ½è®¾ç½®CCRxå¯„å­˜å™¨å€¼ TIM_SetAutoreloadå‡½æ•°èƒ½è®¾ç½®ARRå¯„å­˜å™¨å€¼ TIM_PrescalerConfigå‡½æ•°èƒ½è®¾ç½®PSCå¯„å­˜å™¨å€¼ï¼š TIM_PSCReloadMode_Immediateç«‹å³ç”Ÿæ•ˆ TIM_PSCReloadMode_Updateæ›´æ–°äº‹ä»¶åç”Ÿæ•ˆ TIM_OCxInitå‡½æ•°èƒ½é…ç½®OCxé€šé“ TIM_OCModeä¸ºè¾“å‡ºæ¯”è¾ƒæ¨¡å¼ TIM_OCPolarityä¸ºè¾“å‡ºææ€§ï¼šTIM_OCPolarity_Highæ­£å¸¸ï¼ŒTIM_OCPolarity_Lowç¿»è½¬ TIM_OutputStateä¸ºè¾“å‡ºä½¿èƒ½ï¼šTIM_OutputState_Enableå¼€å¯ï¼ŒTIM_OutputState_Disableå…³é—­ TIM_Pulseä¸ºCCRåˆå§‹å€¼ TIM_OCMode å€¼ æè¿° TIM_OCMode_Timing ((uint16_t)0x0000) å†»ç»“ TIM_OCMode_Active ((uint16_t)0x0010) åŒ¹é…æ—¶ç½®æœ‰æ•ˆç”µå¹³ TIM_OCMode_Inactive ((uint16_t)0x0020) åŒ¹é…æ—¶ç½®æ— æ•ˆç”µå¹³ TIM_OCMode_Toggle ((uint16_t)0x0030) åŒ¹é…æ—¶ç”µå¹³ç¿»è½¬ TIM_OCMode_PWM1 ((uint16_t)0x0060) PWMæ¨¡å¼1 TIM_OCMode_PWM2 ((uint16_t)0x0070) PWMæ¨¡å¼2 è¾“å…¥æ•è· ICï¼ˆInput Captureï¼‰è¾“å…¥æ•è· è¾“å…¥æ•è·æ¨¡å¼ä¸‹ï¼Œå½“é€šé“è¾“å…¥å¼•è„šå‡ºç°æŒ‡å®šç”µå¹³è·³å˜æ—¶ï¼Œå½“å‰CNTçš„å€¼å°†è¢«é”å­˜åˆ°CCRä¸­ï¼Œå¯ç”¨äºæµ‹é‡PWMæ³¢å½¢çš„é¢‘ç‡ã€å ç©ºæ¯”ã€è„‰å†²é—´éš”ã€ç”µå¹³æŒç»­æ—¶é—´ç­‰å‚ æ¯ä¸ªé«˜çº§å®šæ—¶å™¨å’Œé€šç”¨å®šæ—¶å™¨éƒ½æ‹¥æœ‰4ä¸ªè¾“å…¥æ•è·é€šé“ å¯é…ç½®ä¸ºPWMIæ¨¡å¼ï¼ŒåŒæ—¶æµ‹é‡é¢‘ç‡å’Œå ç©ºæ¯” å¯é…åˆä¸»ä»è§¦å‘æ¨¡å¼ï¼Œå®ç°ç¡¬ä»¶å…¨è‡ªåŠ¨æµ‹é‡ é¢‘ç‡æµ‹é‡ æµ‹é¢‘æ³•ï¼šåœ¨é—¸é—¨æ—¶é—´Tå†…ï¼Œå¯¹ä¸Šå‡æ²¿è®¡æ¬¡ï¼Œå¾—åˆ°Nï¼Œåˆ™é¢‘ç‡\n$$ f_x = \\frac{N}{T} $$ æµ‹å‘¨æ³•ï¼šä¸¤ä¸ªä¸Šå‡æ²¿å†…ï¼Œä»¥æ ‡å‡†é¢‘ç‡fcè®¡æ¬¡ï¼Œå¾—åˆ°N ï¼Œåˆ™é¢‘ç‡\n$$ f_x = \\frac{f_c}{N} $$ ä¸­ç•Œé¢‘ç‡ï¼šæµ‹é¢‘æ³•ä¸æµ‹å‘¨æ³•è¯¯å·®ç›¸ç­‰çš„é¢‘ç‡ç‚¹\n$$ f_m = \\sqrt\\frac{f_c}{T} $$ PWMIï¼ˆæµ‹å‘¨æ³•ï¼‰ ä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 //é…ç½®æ—¶é’Ÿ RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //é…ç½®GPIO GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); //é…ç½®å®šæ—¶å™¨ TIM_InternalClockConfig(TIM3); TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure; TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1; TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; TIM_TimeBaseInitStructure.TIM_Period = 65536 - 1; TIM_TimeBaseInitStructure.TIM_Prescaler = 72 - 1; TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0; TIM_TimeBaseInit(TIM3, \u0026amp;TIM_TimeBaseInitStructure); //é…ç½®æ•è·é€šé“ TIM_ICInitTypeDef TIM_ICInitStructure; TIM_ICInitStructure.TIM_Channel = TIM_Channel_1; TIM_ICInitStructure.TIM_ICFilter = 0xF; TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising; TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1; TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; TIM_PWMIConfig(TIM3, \u0026amp;TIM_ICInitStructure); //TIM_ICInit(TIM3, \u0026amp;TIM_ICInitStructure); //é…ç½®ä»æ¨¡å¼ TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1); TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset); //ä½¿èƒ½å®šæ—¶å™¨ TIM_Cmd(TIM3, ENABLE); //è·å–é¢‘ç‡ uint32_t IC_GetFreq(void) { return 1000000 / (TIM_GetCapture1(TIM3) + 1); } //è·å–å ç©ºæ¯” uint32_t IC_GetDuty(void) { return (TIM_GetCapture2(TIM3) + 1) * 100 / (TIM_GetCapture1(TIM3) + 1); } TIM_ICInitTypeDefä¸ºè¾“å…¥æ•è·é…ç½®ç»“æ„ä½“\nTIM_Channelä¸ºè¾“å…¥é€šé“ï¼šTIM_Channel_x(x=1,2,3,4) TIM_ICFilterä¸ºè¾“å…¥æ»¤æ³¢å™¨ï¼š0x0-0xF TIM_ICPolarityä¸ºè¾“å…¥ææ€§é€‰æ‹© TIM_ICPrescalerä¸ºé¢„åˆ†é¢‘é…ç½® TIM_ICSelectionä¸ºä¿¡å·äº¤å‰é€‰æ‹© TIM_PWMIConfigå‡½æ•°ä¼šå¯¹å¦ä¸€é€šé“è¿›è¡Œç›¸åº”é…ç½®ï¼ŒTIM_ICInitå‡½æ•°åªä¼šé…ç½®å½“å‰é€šé“ TIM_GetCapturexå‡½æ•°ä¼šè·å–CCRxå¯„å­˜å™¨çš„å€¼ è®¡ç®—å ç©ºæ¯”æ—¶ï¼Œå¯¹CCR1å’ŒCCR2çš„å€¼+1çš„çš„æ“ä½œå¯ä»¥é¿å…é™¤0ï¼Œå®é™…å€¼åº”ä¸º\n$$ val_1=CCR1+0.5\\quad(\\pm0.5) $$$$ val_2=CCR2+0.5\\quad(\\pm0.5) $$$$ Freq=\\frac{CK_{PSC}}{(PSC+1)*val_1} $$$$ Duty=100\\%*\\frac{val_2}{val_1} $$ä¸»ä»è§¦å‘ ä»æ¨¡å¼ 1 2 TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1); TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset); TIM_SelectInputTriggerå‡½æ•°ç”¨äºé…ç½®ä»æ¨¡å¼è§¦å‘æº TIM_SelectSlaveModeå‡½æ•°ç”¨äºé…ç½®ä»æ¨¡å¼ TIM_InputTriggerSource å€¼ æè¿° TIM_TS_ITR0 ((uint16_t)0x0000) Internal Trigger 0 TIM_TS_ITR1 ((uint16_t)0x0010) Internal Trigger 1 TIM_TS_ITR2 ((uint16_t)0x0020) Internal Trigger 2 TIM_TS_ITR3 ((uint16_t)0x0030) Internal Trigger 3 TIM_TS_TI1F_ED ((uint16_t)0x0040) TI1 Edge Detector TIM_TS_TI1FP1 ((uint16_t)0x0050) Filtered Timer Input 1 TIM_TS_TI2FP2 ((uint16_t)0x0060) Filtered Timer Input 2 TIM_TS_ETRF ((uint16_t)0x0070) External Trigger input TIM_SlaveMode å€¼ æè¿° TIM_SlaveMode_Reset ((uint16_t)0x0004) Rising edge of the selected trigger signal (TRGI) re-initializes\u0026lt;br\u0026gt; the counter and triggers an update of the registers. TIM_SlaveMode_Gated ((uint16_t)0x0005) The counter clock is enabled when the trigger signal (TRGI) is high. TIM_SlaveMode_Trigger ((uint16_t)0x0006) The counter starts at a rising edge of the trigger TRGI. TIM_SlaveMode_External1 ((uint16_t)0x0007) Rising edges of the selected trigger (TRGI) clock the counter. ä¸»æ¨¡å¼ 1 2 TIM_SelectMasterSlaveMode(TIM3, TIM_MasterSlaveMode_Enable); TIM_SelectOutputTrigger(TIM3, TIM_TRGOSource_Update); TIM_SelectMasterSlaveModeå‡½æ•°ç”¨äºä½¿èƒ½ä¸»æ¨¡å¼ï¼š TIM_MasterSlaveMode_Enableå¼€å¯ TIM_MasterSlaveMode_Disableå…³é—­ TIM_SelectOutputTriggerå‡½æ•°ç”¨äºé…ç½®è§¦å‘æº TIM_TRGOSource å€¼ æè¿° TIM_TRGOSource_Reset ((uint16_t)0x0000) The UG bit in the TIM_EGR register is used as the trigger output (TRGO). TIM_TRGOSource_Enable ((uint16_t)0x0010) The Counter Enable CEN is used as the trigger output (TRGO). TIM_TRGOSource_Update ((uint16_t)0x0020) The update event is selected as the trigger output (TRGO). TIM_TRGOSource_OC1 ((uint16_t)0x0030) The trigger output sends a positive pulse when the CC1IF flag is to be set, as soon as a capture or compare match occurs (TRGO). TIM_TRGOSource_OC1Ref ((uint16_t)0x0040) OC1REF signal is used as the trigger output (TRGO). TIM_TRGOSource_OC2Ref ((uint16_t)0x0050) OC2REF signal is used as the trigger output (TRGO). TIM_TRGOSource_OC3Ref ((uint16_t)0x0060) OC3REF signal is used as the trigger output (TRGO). TIM_TRGOSource_OC4Ref ((uint16_t)0x0070) OC4REF signal is used as the trigger output (TRGO). ç¼–ç å™¨æ¥å£ Encoder Interface ç¼–ç å™¨æ¥å£ ç¼–ç å™¨æ¥å£å¯æ¥æ”¶å¢é‡ï¼ˆæ­£äº¤ï¼‰ç¼–ç å™¨çš„ä¿¡å·ï¼Œæ ¹æ®ç¼–ç å™¨æ—‹è½¬äº§ç”Ÿçš„æ­£äº¤ä¿¡å·è„‰å†²ï¼Œè‡ªåŠ¨æ§åˆ¶CNTè‡ªå¢æˆ–è‡ªå‡ï¼Œä»è€ŒæŒ‡ç¤ºç¼–ç å™¨çš„ä½ç½®ã€æ—‹è½¬æ–¹å‘å’Œæ—‹è½¬é€Ÿåº¦ æ¯ä¸ªé«˜çº§å®šæ—¶å™¨å’Œé€šç”¨å®šæ—¶å™¨éƒ½æ‹¥æœ‰1ä¸ªç¼–ç å™¨æ¥å£ ä¸¤ä¸ªè¾“å…¥å¼•è„šå€Ÿç”¨äº†è¾“å…¥æ•è·çš„é€šé“1å’Œé€šé“2 ä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 //é…ç½®æ—¶é’Ÿ RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //GPIOé…ç½®ï¼ˆé…ç½®CH1å’ŒCH2ï¼‰ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); //æ—¶åŸºå•å…ƒé…ç½® TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure; TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1; TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; TIM_TimeBaseInitStructure.TIM_Period = 65536 - 1; TIM_TimeBaseInitStructure.TIM_Prescaler = 1 - 1; TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0; TIM_TimeBaseInit(TIM3, \u0026amp;TIM_TimeBaseInitStructure); //é€šé“é…ç½®ï¼ˆé…ç½®CH1å’ŒCH2ï¼‰ TIM_ICInitTypeDef TIM_ICInitStructure; TIM_ICStructInit(\u0026amp;TIM_ICInitStructure); TIM_ICInitStructure.TIM_ICFilter = 0xF; TIM_ICInitStructure.TIM_Channel = TIM_Channel_1; TIM_ICInit(TIM3, \u0026amp;TIM_ICInitStructure); TIM_ICInitStructure.TIM_Channel = TIM_Channel_2; TIM_ICInit(TIM3, \u0026amp;TIM_ICInitStructure); //é…ç½®ç¼–ç å™¨æ¥å£ TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12, TIM_ICPolarity_Rising, TIM_ICPolarity_Rising); //ä½¿èƒ½å®šæ—¶å™¨ TIM_Cmd(TIM3, ENABLE); int16_t Encoder_Get(void) { // int16_t Temp; // Temp = TIM_GetCounter(TIM3); // TIM_SetCounter(TIM3, 0); // return Temp; return TIM_GetCounter(TIM3); } TIM_EncoderInterfaceConfigä¸ºç¼–ç å™¨é…ç½®å‡½æ•° TIM_ICxPolarityå‚æ•°ä¸é€šé“é…ç½®é‡å¤ TIM_ICPolarity_Risingä»£è¡¨ä¸åç›¸ï¼ŒTIM_ICPolarity_Fallingè¡¨ç¤ºåç›¸ TIM_EncoderMode å€¼ æè¿° TIM_EncoderMode_TI1 ((uint16_t)0x0001) Counter counts on TI1FP1 edge depending on TI2FP2 level. TIM_EncoderMode_TI2 ((uint16_t)0x0002) Counter counts on TI2FP2 edge depending on TI1FP1 level. TIM_EncoderMode_TI12 ((uint16_t)0x0003) Counter counts on both TI1FP1 and TI2FP2 edges depending on the level of the other input. ","date":"2024-02-05T00:00:00Z","permalink":"https://detail47.github.io/p/stm32-tim/","title":"STM32 TIM"},{"content":"STM32 STM32æ˜¯STå…¬å¸åŸºäºARM Cortex-Må†…æ ¸å¼€å‘çš„32ä½å¾®æ§åˆ¶å™¨ STM32å¸¸åº”ç”¨åœ¨åµŒå…¥å¼é¢†åŸŸï¼Œå¦‚æ™ºèƒ½è½¦ã€æ— äººæœºã€æœºå™¨äººã€æ— çº¿é€šä¿¡ã€ç‰©è”ç½‘ã€å·¥ä¸šæ§åˆ¶ã€å¨±ä¹ç”µå­äº§å“ç­‰ STM32åŠŸèƒ½å¼ºå¤§ã€æ€§èƒ½ä¼˜å¼‚ã€ç‰‡ä¸Šèµ„æºä¸°å¯Œã€åŠŸè€—ä½ï¼Œæ˜¯ä¸€æ¬¾ç»å…¸çš„åµŒå…¥å¼å¾®æ§åˆ¶å™¨ ARM ARMæ—¢æŒ‡ARMå…¬å¸ï¼Œä¹ŸæŒ‡ARMå¤„ç†å™¨å†…æ ¸ ARMå…¬å¸æ˜¯å…¨çƒé¢†å…ˆçš„åŠå¯¼ä½“çŸ¥è¯†äº§æƒï¼ˆIPï¼‰æä¾›å•†ï¼Œå…¨ä¸–ç•Œè¶…è¿‡95%çš„æ™ºèƒ½æ‰‹æœºå’Œå¹³æ¿ç”µè„‘éƒ½é‡‡ç”¨ARMæ¶æ„ ARMå…¬å¸è®¾è®¡ARMå†…æ ¸ï¼ŒåŠå¯¼ä½“å‚å•†å®Œå–„å†…æ ¸å‘¨è¾¹ç”µè·¯å¹¶ç”Ÿäº§èŠ¯ç‰‡ STM32F103C8T6 ç³»åˆ—ï¼šä¸»æµç³»åˆ—STM32F1 å†…æ ¸ï¼šARM Cortex-M3 ä¸»é¢‘ï¼š72MHz RAMï¼š20Kï¼ˆSRAMï¼‰ ROMï¼š64Kï¼ˆFlashï¼‰ ä¾›ç”µï¼š2.0~3.6Vï¼ˆæ ‡å‡†3.3Vï¼‰ å°è£…ï¼šLQFP48 ç‰‡ä¸Šèµ„æº/å¤–è®¾ è‹±æ–‡ç¼©å†™ åç§° NVIC åµŒå¥—å‘é‡ä¸­æ–­æ§åˆ¶å™¨ SysTick ç³»ç»Ÿæ»´ç­”å®šæ—¶å™¨ RCC å¤ä½å’Œæ—¶é’Ÿæ§åˆ¶ GPIO é€šç”¨IOå£ AFIO å¤ç”¨IOå£ EXTI å¤–éƒ¨ä¸­æ–­ TIM å®šæ—¶å™¨ ADC æ¨¡æ•°è½¬æ¢å™¨ DMA ç›´æ¥å†…å­˜è®¿é—® USART åŒæ­¥/å¼‚æ­¥ä¸²å£é€šä¿¡ I2C I2Cé€šä¿¡ SPI SPIé€šä¿¡ CAN CANé€šä¿¡ USB USBé€šä¿¡ RTC å®æ—¶æ—¶é’Ÿ CRC CRCæ ¡éªŒ PWR ç”µæºæ§åˆ¶ BKP å¤‡ä»½å¯„å­˜å™¨ IWDG ç‹¬ç«‹çœ‹é—¨ç‹— WWDG çª—å£çœ‹é—¨ç‹— DAC æ•°æ¨¡è½¬æ¢å™¨ SDIO SDå¡æ¥å£ FSMC å¯å˜é™æ€å­˜å‚¨æ§åˆ¶å™¨ USB OTG USBä¸»æœºæ¥å£ å‘½åè§„åˆ™ å¼•è„šå®šä¹‰ å¼•è„šé‡æ˜ å°„ 1 2 3 RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2, ENABLE); GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE); ä½¿ç”¨å¼•è„šé‡æ˜ å°„æ—¶ï¼Œéœ€è¦å¼€å¯AFIOæ—¶é’Ÿ è¯¥ä»£ç ç¦ç”¨PA15å’ŒPB3çš„JTAGè°ƒè¯•ï¼Œé‡æ˜ å°„ä¸ºTIM2 æ›´å¤šPinRemapConfigçš„ç›¸å…³å†…å®¹ï¼šSTM32F10xxxå‚è€ƒæ‰‹å†Œï¼ˆä¸­æ–‡ï¼‰.pdf é¡µç 116/æ‰‹å†Œ8.3\nå¯åŠ¨é…ç½® æœ€å°ç³»ç»Ÿç”µè·¯ RCCæ—¶é’Ÿæ ‘ ","date":"2024-02-05T00:00:00Z","permalink":"https://detail47.github.io/p/stm32%E7%AE%80%E4%BB%8B/","title":"STM32ç®€ä»‹"},{"content":"ä¸­æ–­ ä¸­æ–­ï¼šåœ¨ä¸»ç¨‹åºè¿è¡Œè¿‡ç¨‹ä¸­ï¼Œå‡ºç°äº†ç‰¹å®šçš„ä¸­æ–­è§¦å‘æ¡ä»¶ï¼ˆä¸­æ–­æºï¼‰ï¼Œä½¿å¾—CPUæš‚åœå½“å‰æ­£åœ¨è¿è¡Œçš„ç¨‹åºï¼Œè½¬è€Œå»å¤„ç†ä¸­æ–­ç¨‹åºï¼Œå¤„ç†å®Œæˆååˆè¿”å›åŸæ¥è¢«æš‚åœçš„ä½ç½®ç»§ç»­è¿è¡Œ ä¸­æ–­ä¼˜å…ˆçº§ï¼šå½“æœ‰å¤šä¸ªä¸­æ–­æºåŒæ—¶ç”³è¯·ä¸­æ–­æ—¶ï¼ŒCPUä¼šæ ¹æ®ä¸­æ–­æºçš„è½»é‡ç¼“æ€¥è¿›è¡Œè£å†³ï¼Œä¼˜å…ˆå“åº”æ›´åŠ ç´§æ€¥çš„ä¸­æ–­æº ä¸­æ–­åµŒå¥—ï¼šå½“ä¸€ä¸ªä¸­æ–­ç¨‹åºæ­£åœ¨è¿è¡Œæ—¶ï¼Œåˆæœ‰æ–°çš„æ›´é«˜ä¼˜å…ˆçº§çš„ä¸­æ–­æºç”³è¯·ä¸­æ–­ï¼ŒCPUå†æ¬¡æš‚åœå½“å‰ä¸­æ–­ç¨‹åºï¼Œè½¬è€Œå»å¤„ç†æ–°çš„ä¸­æ–­ç¨‹åºï¼Œå¤„ç†å®Œæˆåä¾æ¬¡è¿›è¡Œè¿”å› STM32ä¸­æ–­ 68ä¸ªå¯å±è”½ä¸­æ–­é€šé“ï¼ŒåŒ…å«EXTIã€TIMã€ADCã€USARTã€SPIã€I2Cã€RTCç­‰å¤šä¸ªå¤–è®¾ ä½¿ç”¨NVICç»Ÿä¸€ç®¡ç†ä¸­æ–­ï¼Œæ¯ä¸ªä¸­æ–­é€šé“éƒ½æ‹¥æœ‰16ä¸ªå¯ç¼–ç¨‹çš„ä¼˜å…ˆç­‰çº§ï¼Œå¯å¯¹ä¼˜å…ˆçº§è¿›è¡Œåˆ†ç»„ï¼Œè¿›ä¸€æ­¥è®¾ç½®æŠ¢å ä¼˜å…ˆçº§å’Œå“åº”ä¼˜å…ˆçº§ NVIC åŸºæœ¬ç»“æ„ ä¼˜å…ˆçº§åˆ†ç»„ NVICçš„ä¸­æ–­ä¼˜å…ˆçº§ç”±ä¼˜å…ˆçº§å¯„å­˜å™¨çš„4ä½ï¼ˆ0~15ï¼‰å†³å®šï¼Œè¿™4ä½å¯ä»¥è¿›è¡Œåˆ‡åˆ†ï¼Œåˆ†ä¸ºé«˜nä½çš„æŠ¢å ä¼˜å…ˆçº§å’Œä½4-nä½çš„å“åº”ä¼˜å…ˆçº§ æŠ¢å ä¼˜å…ˆçº§é«˜çš„å¯ä»¥ä¸­æ–­åµŒå¥—ï¼Œå“åº”ä¼˜å…ˆçº§é«˜çš„å¯ä»¥ä¼˜å…ˆæ’é˜Ÿï¼ŒæŠ¢å ä¼˜å…ˆçº§å’Œå“åº”ä¼˜å…ˆçº§å‡ç›¸åŒçš„æŒ‰ä¸­æ–­å·æ’é˜Ÿ åˆ†ç»„æ–¹å¼ æŠ¢å ä¼˜å…ˆçº§ å“åº”ä¼˜å…ˆçº§ å® å€¼ åˆ†ç»„0 0ä½ï¼Œå–å€¼ä¸º0 4ä½ï¼Œå–å€¼ä¸º0~15 NVIC_PriorityGroup_0 ((uint32_t)0x700) åˆ†ç»„1 1ä½ï¼Œå–å€¼ä¸º0~1 3ä½ï¼Œå–å€¼ä¸º0~7 NVIC_PriorityGroup_1 ((uint32_t)0x600) åˆ†ç»„2 2ä½ï¼Œå–å€¼ä¸º0~3 2ä½ï¼Œå–å€¼ä¸º0~3 NVIC_PriorityGroup_2 ((uint32_t)0x500) åˆ†ç»„3 3ä½ï¼Œå–å€¼ä¸º0~7 1ä½ï¼Œå–å€¼ä¸º0~1 NVIC_PriorityGroup_3 ((uint32_t)0x400) åˆ†ç»„4 4ä½ï¼Œå–å€¼ä¸º0~15 0ä½ï¼Œå–å€¼ä¸º0 NVIC_PriorityGroup_4 ((uint32_t)0x300) ä»£ç  1 2 3 4 5 6 7 8 9 10 //NVICä¸­æ–­ä¼˜å…ˆçº§åˆ†ç»„ NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //NVICé…ç½® NVIC_InitTypeDef NVIC_InitStructure; NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn; NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1; NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; NVIC_Init(\u0026amp;NVIC_InitStructure); NVIC_InitTypeDefä¸ºNVICåˆå§‹åŒ–ç»“æ„ä½“\nNVIC_IRQChannelä¸ºä¸­æ–­é€šé“ ( IRQChannel ) NVIC_IRQChannelCmdä¸ºé€šé“ä½¿èƒ½ï¼šENABLEä¸ºå¼€å¯ï¼ŒDISABLEä¸ºå…³é—­ NVIC_IRQChannelPreemptionPriorityä¸ºæŠ¢å ä¼˜å…ˆçº§ NVIC_IRQChannelSubPriorityä¸ºå“åº”ä¼˜å…ˆçº§ ä¸­æ–­è§¦å‘åï¼Œå°†ä¼šè¿›å…¥ä¸­æ–­å‡½æ•° void xHandler(void) EXTI_GetITStatuså‡½æ•°å¯è·å–æŸä¸ªä¸­æ–­æ ‡å¿—ä½ EXTI_ClearITPendingBitå‡½æ•°å¯æ¸…é™¤æŸä¸ªä¸­æ–­æ ‡å¿—ä½ï¼ˆ\u0026lt;u\u0026gt;å¿…é¡» \u0026lt;/u\u0026gt;ï¼‰ ä¸­æ–­é€šé“ï¼ˆä»¥STM32F10X_MDä¸ºå‡†ï¼‰ NVIC_IRQChannel å€¼ æè¿° WWDG_IRQn 0 Window WatchDog Interrupt PVD_IRQn 1 PVD through EXTI Line detection Interrupt TAMPER_IRQn 2 Tamper Interrupt RTC_IRQn 3 RTC global Interrupt FLASH_IRQn 4 FLASH global Interrupt RCC_IRQn 5 RCC global Interrupt EXTI0_IRQn 6 EXTI Line0 Interrupt EXTI1_IRQn 7 EXTI Line1 Interrupt EXTI2_IRQn 8 EXTI Line2 Interrupt EXTI3_IRQn 9 EXTI Line3 Interrupt EXTI4_IRQn 10 EXTI Line4 Interrupt DMA1_Channel1_IRQn 11 DMA1 Channel 1 global Interrupt DMA1_Channel2_IRQn 12 DMA1 Channel 2 global Interrupt DMA1_Channel3_IRQn 13 DMA1 Channel 3 global Interrupt DMA1_Channel4_IRQn 14 DMA1 Channel 4 global Interrupt DMA1_Channel5_IRQn 15 DMA1 Channel 5 global Interrupt DMA1_Channel6_IRQn 16 DMA1 Channel 6 global Interrupt DMA1_Channel7_IRQn 17 DMA1 Channel 7 global Interrupt ADC1_2_IRQn 18 ADC1 and ADC2 global Interrupt USB_HP_CAN1_TX_IRQn 19 USB Device High Priority or CAN1 TX Interrupts USB_LP_CAN1_RX0_IRQn 20 USB Device Low Priority or CAN1 RX0 Interrupts CAN1_RX1_IRQn 21 CAN1 RX1 Interrupt CAN1_SCE_IRQn 22 CAN1 SCE Interrupt EXTI9_5_IRQn 23 External Line[9:5] Interrupts TIM1_BRK_IRQn 24 TIM1 Break Interrupt TIM1_UP_IRQn 25 TIM1 Update Interrupt TIM1_TRG_COM_IRQn 26 TIM1 Trigger and Commutation Interrupt TIM1_CC_IRQn 27 TIM1 Capture Compare Interrupt TIM2_IRQn 28 TIM2 global Interrupt TIM3_IRQn 29 TIM3 global Interrupt TIM4_IRQn 30 TIM4 global Interrupt I2C1_EV_IRQn 31 I2C1 Event Interrupt I2C1_ER_IRQn 32 I2C1 Error Interrupt I2C2_EV_IRQn 33 I2C2 Event Interrupt I2C2_ER_IRQn 34 I2C2 Error Interrupt SPI1_IRQn 35 SPI1 global Interrupt SPI2_IRQn 36 SPI2 global Interrupt USART1_IRQn 37 USART1 global Interrupt USART2_IRQn 38 USART2 global Interrupt USART3_IRQn 39 USART3 global Interrupt EXTI15_10_IRQn 40 External Line[15:10] Interrupts RTCAlarm_IRQn 41 RTC Alarm through EXTI Line Interrupt USBWakeUp_IRQn 42 USB Device WakeUp from suspend through EXTI Line Interrupt EXTI åŸºæœ¬ç»“æ„ EXTIï¼ˆExtern Interruptï¼‰å¤–éƒ¨ä¸­æ–­ EXTIå¯ä»¥ç›‘æµ‹æŒ‡å®šGPIOå£çš„ç”µå¹³ä¿¡å·ï¼Œå½“å…¶æŒ‡å®šçš„GPIOå£äº§ç”Ÿç”µå¹³å˜åŒ–æ—¶ï¼ŒEXTIå°†ç«‹å³å‘NVICå‘å‡ºä¸­æ–­ç”³è¯·ï¼Œç»è¿‡NVICè£å†³åå³å¯ä¸­æ–­CPUä¸»ç¨‹åºï¼Œä½¿CPUæ‰§è¡ŒEXTIå¯¹åº”çš„ä¸­æ–­ç¨‹åº æ”¯æŒçš„è§¦å‘æ–¹å¼ï¼šä¸Šå‡æ²¿/ä¸‹é™æ²¿/åŒè¾¹æ²¿/è½¯ä»¶è§¦å‘ æ”¯æŒçš„GPIOå£ï¼šæ‰€æœ‰GPIOå£ï¼Œä½†ç›¸åŒçš„Pinä¸èƒ½åŒæ—¶è§¦å‘ä¸­æ–­ é€šé“æ•°ï¼š16ä¸ªGPIO_Pinï¼Œå¤–åŠ PVDè¾“å‡ºã€RTCé—¹é’Ÿã€USBå”¤é†’ã€ä»¥å¤ªç½‘å”¤é†’ è§¦å‘å“åº”æ–¹å¼ï¼šä¸­æ–­å“åº”/äº‹ä»¶å“åº” ä»£ç  1 2 3 4 5 6 EXTI_InitTypeDef EXTI_InitStructure; EXTI_InitStructure.EXTI_Line = EXTI_Line14; EXTI_InitStructure.EXTI_LineCmd = ENABLE; EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; EXTI_Init(\u0026amp;EXTI_InitStructure); EXTI_Lineä¸ºä¸­æ–­çº¿æ¥æº EXTI_LineCmdä¸ºä¸­æ–­çº¿ä½¿èƒ½ï¼šENABLEä¸ºå¼€å¯ï¼ŒDISABLEä¸ºå…³é—­ EXTI_Modeä¸ºEXTIçš„æ¨¡å¼ EXTI_Triggerä¸ºè§¦å‘è¾¹ç¼˜ EXTI_Line å€¼ æè¿° EXTI_Line0 ((uint32_t)0x00001) External interrupt line 0 EXTI_Line1 ((uint32_t)0x00002) External interrupt line 1 EXTI_Line2 ((uint32_t)0x00004) External interrupt line 2 EXTI_Line3 ((uint32_t)0x00008) External interrupt line 3 EXTI_Line4 ((uint32_t)0x00010) External interrupt line 4 EXTI_Line5 ((uint32_t)0x00020) External interrupt line 5 EXTI_Line6 ((uint32_t)0x00040) External interrupt line 6 EXTI_Line7 ((uint32_t)0x00080) External interrupt line 7 EXTI_Line8 ((uint32_t)0x00100) External interrupt line 8 EXTI_Line9 ((uint32_t)0x00200) External interrupt line 9 EXTI_Line10 ((uint32_t)0x00400) External interrupt line 10 EXTI_Line11 ((uint32_t)0x00800) External interrupt line 11 EXTI_Line12 ((uint32_t)0x01000) External interrupt line 12 EXTI_Line13 ((uint32_t)0x02000) External interrupt line 13 EXTI_Line14 ((uint32_t)0x04000) External interrupt line 14 EXTI_Line15 ((uint32_t)0x08000) External interrupt line 15 EXTI_Line16 ((uint32_t)0x10000) External interrupt line 16 Connected to the PVD Output EXTI_Line17 ((uint32_t)0x20000) External interrupt line 17 Connected to the RTC Alarm event EXTI_Line18 ((uint32_t)0x40000) External interrupt line 18 Connected to the USB Device/USB OTG FS Wakeup from suspend event EXTI_Line19 ((uint32_t)0x80000) External interrupt line 19 Connected to the Ethernet Wakeup event AFIO åŸºæœ¬ç»“æ„ AFIOä¸»è¦ç”¨äºå¼•è„šå¤ç”¨åŠŸèƒ½çš„é€‰æ‹©å’Œé‡å®šä¹‰ åœ¨STM32ä¸­ï¼ŒAFIOä¸»è¦å®Œæˆä¸¤ä¸ªä»»åŠ¡ï¼šå¤ç”¨åŠŸèƒ½å¼•è„šé‡æ˜ å°„ã€ä¸­æ–­å¼•è„šé€‰æ‹© ä»£ç  1 2 3 4 //å¼€å¯æ—¶é’Ÿ RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); //é…ç½®AFIO GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource14); GPIO_PortSourceGPIOxä¸ºé€‰æ‹©çš„GPIO_Port GPIO_PinSourceä¸ºé€‰æ‹©çš„GPIO_Pin å¤–éƒ¨ä¸­æ–­å®Œæ•´é…ç½®æµç¨‹ é…ç½®æ—¶é’Ÿ GPIOæ—¶é’Ÿ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); AFIOæ—¶é’Ÿ RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); é…ç½®GPIO GPIO_Init(GPIOB, \u0026amp;GPIO_InitStructure); é…ç½®AFIO GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource14); é…ç½®EXTI EXTI_Init(\u0026amp;EXTI_InitStructure); é…ç½®NVIC ä¸­æ–­åˆ†ç»„ NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); ä¸­æ–­é…ç½® NVIC_Init(\u0026amp;NVIC_InitStructure); ","date":"2024-02-02T00:00:00Z","permalink":"https://detail47.github.io/p/stm32-exti/","title":"STM32 EXTI"},{"content":"GPIOæ¦‚è¿° GPIO(General Purpose Input Output)é€šç”¨è¾“å…¥è¾“å‡ºå£ å¯é…ç½®ä¸º8ç§è¾“å…¥è¾“å‡ºæ¨¡å¼ å¼•è„šç”µå¹³ï¼š0V~3.3Vï¼Œéƒ¨åˆ†å¼•è„šå¯å®¹å¿5V è¾“å‡ºæ¨¡å¼ä¸‹å¯æ§åˆ¶ç«¯å£è¾“å‡ºé«˜ä½ç”µå¹³ï¼Œç”¨ä»¥é©±åŠ¨LEDã€æ§åˆ¶èœ‚é¸£å™¨ã€æ¨¡æ‹Ÿé€šä¿¡åè®®è¾“å‡ºæ—¶åºç­‰ è¾“å…¥æ¨¡å¼ä¸‹å¯è¯»å–ç«¯å£çš„é«˜ä½ç”µå¹³æˆ–ç”µå‹ï¼Œç”¨äºè¯»å–æŒ‰é”®è¾“å…¥ã€å¤–æ¥æ¨¡å—ç”µå¹³ä¿¡å·è¾“å…¥ã€ADCç”µå‹é‡‡é›†ã€æ¨¡æ‹Ÿé€šä¿¡åè®®æ¥æ”¶æ•°æ®ç­‰ GPIOè¯¦ç»†ä»‹ç» GPIOåŸºæœ¬ç»“æ„ æ‰€æœ‰GPIOéƒ½å¤„äºAPB2æ€»çº¿ä¸Šï¼Œå› æ­¤ä½¿ç”¨GPIOæ—¶åŠ¡å¿…å¼€å¯APB2æ€»çº¿çš„æ—¶é’Ÿã€‚\nIOå£ç»“æ„ å›¾ä¸­é”™è¯¯: å›¾ä¸­TTLè‚–ç‰¹åŸºè§¦å‘å™¨åº”ä¸ºTTLæ–½å¯†ç‰¹è§¦å‘å™¨\nGPIOçš„ä¸åŒæ¨¡å¼ æ¨¡å¼åç§° æ€§è´¨ ç‰¹å¾ æµ®ç©ºè¾“å…¥ æ•°å­—è¾“å…¥ å¯è¯»å–å¼•è„šç”µå¹³ï¼Œè‹¥å¼•è„šæ‚¬ç©ºï¼Œåˆ™ç”µå¹³ä¸ç¡®å®š ä¸Šæ‹‰è¾“å…¥ æ•°å­—è¾“å…¥ å¯è¯»å–å¼•è„šç”µå¹³ï¼Œå†…éƒ¨è¿æ¥ä¸Šæ‹‰ç”µé˜»ï¼Œæ‚¬ç©ºæ—¶é»˜è®¤é«˜ç”µå¹³ ä¸‹æ‹‰è¾“å…¥ æ•°å­—è¾“å…¥ å¯è¯»å–å¼•è„šç”µå¹³ï¼Œå†…éƒ¨è¿æ¥ä¸‹æ‹‰ç”µé˜»ï¼Œæ‚¬ç©ºæ—¶é»˜è®¤ä½ç”µå¹³ æ¨¡æ‹Ÿè¾“å…¥ æ¨¡æ‹Ÿè¾“å…¥ GPIOæ— æ•ˆï¼Œå¼•è„šç›´æ¥æ¥å…¥å†…éƒ¨ADC å¼€æ¼è¾“å‡º æ•°å­—è¾“å‡º å¯è¾“å‡ºå¼•è„šç”µå¹³ï¼Œé«˜ç”µå¹³ä¸ºé«˜é˜»æ€ï¼Œä½ç”µå¹³æ¥VSS æ¨æŒ½è¾“å‡º æ•°å­—è¾“å‡º å¯è¾“å‡ºå¼•è„šç”µå¹³ï¼Œé«˜ç”µå¹³æ¥VDDï¼Œä½ç”µå¹³æ¥VSS å¤ç”¨å¼€æ¼è¾“å‡º æ•°å­—è¾“å‡º ç”±ç‰‡ä¸Šå¤–è®¾æ§åˆ¶ï¼Œé«˜ç”µå¹³ä¸ºé«˜é˜»æ€ï¼Œä½ç”µå¹³æ¥VSS å¤ç”¨æ¨æŒ½è¾“å‡º æ•°å­—è¾“å‡º ç”±ç‰‡ä¸Šå¤–è®¾æ§åˆ¶ï¼Œé«˜ç”µå¹³æ¥VDDï¼Œä½ç”µå¹³æ¥VSS ä»£ç å®ç° ç»“æ„ä½“ 1 2 3 4 5 6 7 8 //å¼€å¯æ—¶é’Ÿ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //é…ç½®GPIO GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); GPIO_InitTypeDefä¸ºGPIOåˆå§‹åŒ–ç»“æ„ä½“\nGPIO_Modeä¸ºGPIOå£æ¨¡å¼ GPIO_Pinä¸ºGPIOå¼•è„šç¼–å·ï¼Œå’Œ GPIO_Initçš„ç¬¬ä¸€ä¸ªå‚æ•°å…±åŒæŒ‡å®šå¼•è„š GPIO_Speedä¸ºGPIOå·¥ä½œé€Ÿåº¦ æ¨¡å¼ GPIO_Mode å€¼ æ¨¡æ‹Ÿè¾“å…¥ GPIO_Mode_AIN 0x0 æµ®ç©ºè¾“å…¥ GPIO_Mode_IN_FLOATING 0x04 ä¸‹æ‹‰è¾“å…¥ GPIO_Mode_IPD 0x28 ä¸Šæ‹‰è¾“å…¥ GPIO_Mode_IPU 0x48 å¼€æ¼è¾“å‡º GPIO_Mode_Out_OD 0x14 æ¨æŒ½è¾“å‡º GPIO_Mode_Out_PP 0x10 å¤ç”¨å¼€æ¼è¾“å‡º GPIO_Mode_AF_OD 0x1C å¤ç”¨æ¨æŒ½è¾“å‡º GPIO_Mode_AF_PP 0x18 é€Ÿåº¦ GPIO_Speed å€¼ 10M GPIO_Speed_10MHz 1 2M GPIO_Speed_2MHz 2 50M GPIO_Speed_50MHz 3 GPIOè¾“å‡º 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //æ–¹æ³•1 GPIO_ResetBits(GPIOA, GPIO_Pin_0); GPIO_SetBits(GPIOA, GPIO_Pin_0); //æ–¹æ³•2 GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_RESET); GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_SET); //æ–¹æ³•3 GPIO_WriteBit(GPIOA, GPIO_Pin_0, (BitAction)0); GPIO_WriteBit(GPIOA, GPIO_Pin_0, (BitAction)1); //æ–¹æ³•4 uint16_t data = 0x00; GPIO_Write(GPIOA, data); GPIOè¾“å…¥ 1 2 3 4 5 6 7 8 9 //æ–¹æ³•1 uint8_t data = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0); //æ–¹æ³•2 uint16_t data = GPIO_ReadInputData(GPIOA); //è¯»å–è¾“å‡ºå¯„å­˜å™¨ uint8_t data = GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_0); uint16_t data = GPIO_ReadOutputData(GPIOA); ","date":"2024-01-31T00:00:00Z","permalink":"https://detail47.github.io/p/stm32-gpio/","title":"STM32 GPIO"}]